//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2020 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//

%{
  from gyb_utils import autogenerated_warning

  atomicTypes = [
    "Int", "UInt",
    "Int64", "UInt64",
    "Int32", "UInt32",
    "Int16", "UInt16",
    "Int8", "UInt8",
  ]

  rmwOrderings = [
    'relaxed',
    'acquiring',
    'releasing',
    'acquiringAndReleasing',
    'sequentiallyConsistent',
  ]

  loadOrderings = [
    'relaxed',
    'acquiring',
    'sequentiallyConsistent',
  ]

  storeOrderings = [
    'relaxed',
    'releasing',
    'sequentiallyConsistent',
  ]

  def lowerFirst(str):
    return str[:1].lower() + str[1:] if str else ""

  def argLabel(label):
    return label + ": " if label <> "_" else ""

  integerOperations = [
    # Swift name,         llvm name,  operator, label, doc
    ('WrappingIncrement', 'add',      '&+',     "by",   "wrapping add"),
    ('WrappingDecrement', 'sub',      '&-',     "by",   "wrapping subtract"),
    ('BitwiseAnd',        'and',      '&',      "with", "bitwise and"),
    ('BitwiseOr',         'or',       '|',      "with", "bitwise or"),
    ('BitwiseXor',        'xor',      '^',      "with", "bitwise xor")
  ]

  def argLabel(label):
    return label + ": " if label <> "_" else ""
}%
${autogenerated_warning()}

import XCTest
import SE0282_Experimental

class UnsafeAtomicIntegersTests: XCTestCase {

% for type in atomicTypes:

  func test_${type}_create_destroy() {
    let v = UnsafeAtomic<${type}>.create(initialValue: 0)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), 0)

    let w = UnsafeAtomic<${type}>.create(initialValue: 42)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), 42)
  }

% for order in loadOrderings:
  func test_${type}_load_${order}() {
    let v = UnsafeAtomic<${type}>.create(initialValue: 0)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .${order}), 0)

    let w = UnsafeAtomic<${type}>.create(initialValue: 23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .${order}), 23)
  }
% end

% for order in storeOrderings:
  func test_${type}_store_${order}() {
    let v = UnsafeAtomic<${type}>.create(initialValue: 0)
    defer { v.destroy() }

    v.store(23, ordering: .${order})
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    v.store(42, ordering: .${order})
    XCTAssertEqual(v.load(ordering: .relaxed), 42)
  }
% end

% for order in rmwOrderings:
  func test_${type}_exchange_${order}() {
    let v = UnsafeAtomic<${type}>.create(initialValue: 0)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(42, ordering: .${order}), 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)

    XCTAssertEqual(v.exchange(23, ordering: .${order}), 42)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
% end

% for order in rmwOrderings:
  func test_${type}_compareExchange_${order}() {
    let v = UnsafeAtomic<${type}>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      ordering: .${order})
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      ordering: .${order})
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      ordering: .${order})
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
% end

% for operation in ["compareExchange", "weakCompareExchange"]:
%   for successorder in rmwOrderings:
%     for failorder in loadOrderings:
  func test_${type}_${operation}_${successorder}_${failorder}() {
    let v = UnsafeAtomic<${type}>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.${operation}(
      expected: 0,
      desired: 1,
      successOrdering: .${successorder},
      failureOrdering: .${failorder})
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.${operation}(
      expected: 0,
      desired: 2,
      successOrdering: .${successorder},
      failureOrdering: .${failorder})
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.${operation}(
      expected: 1,
      desired: 2,
      successOrdering: .${successorder},
      failureOrdering: .${failorder})
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
%     end
%   end
% end

% for (name, _, operator, label, _) in integerOperations:
%   for order in rmwOrderings:
  func test_${type}_loadThen${name}_${order}() {
    let a: ${type} = 3
    let b: ${type} = 8
    let c: ${type} = 12
    let result1: ${type} = a ${operator} b
    let result2: ${type} = result1 ${operator} c

    let v = UnsafeAtomic<${type}>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThen${name}(${argLabel(label)}b, ordering: .${order})
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThen${name}(${argLabel(label)}c, ordering: .${order})
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
%   end
% end

% for (name, _, operator, label, _) in integerOperations:
%   for order in rmwOrderings:
  func test_${type}_${lowerFirst(name)}ThenLoad_${order}() {
    let a: ${type} = 3
    let b: ${type} = 8
    let c: ${type} = 12
    let result1: ${type} = a ${operator} b
    let result2: ${type} = result1 ${operator} c

    let v = UnsafeAtomic<${type}>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.${lowerFirst(name)}ThenLoad(${argLabel(label)}b, ordering: .${order})
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.${lowerFirst(name)}ThenLoad(${argLabel(label)}c, ordering: .${order})
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
%   end
% end

% end
}
