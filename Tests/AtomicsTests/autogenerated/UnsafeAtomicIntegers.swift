//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift.org open source project
//
// Copyright (c) 2020 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
// See https://swift.org/CONTRIBUTORS.txt for the list of Swift project authors
//
//===----------------------------------------------------------------------===//


// #############################################################################
// #                                                                           #
// #            DO NOT EDIT THIS FILE; IT IS AUTOGENERATED.                    #
// #                                                                           #
// #############################################################################


import XCTest
import SE0282_Experimental

class UnsafeAtomicIntegersTests: XCTestCase {


  func test_Int_create_destroy() {
    let v = UnsafeAtomic<Int>.create(initialValue: 0)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), 0)

    let w = UnsafeAtomic<Int>.create(initialValue: 42)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), 42)
  }

  func test_Int_load_relaxed() {
    let v = UnsafeAtomic<Int>.create(initialValue: 0)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), 0)

    let w = UnsafeAtomic<Int>.create(initialValue: 23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), 23)
  }
  func test_Int_load_acquiring() {
    let v = UnsafeAtomic<Int>.create(initialValue: 0)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .acquiring), 0)

    let w = UnsafeAtomic<Int>.create(initialValue: 23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .acquiring), 23)
  }
  func test_Int_load_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int>.create(initialValue: 0)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .sequentiallyConsistent), 0)

    let w = UnsafeAtomic<Int>.create(initialValue: 23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .sequentiallyConsistent), 23)
  }

  func test_Int_store_relaxed() {
    let v = UnsafeAtomic<Int>.create(initialValue: 0)
    defer { v.destroy() }

    v.store(23, ordering: .relaxed)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    v.store(42, ordering: .relaxed)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)
  }
  func test_Int_store_releasing() {
    let v = UnsafeAtomic<Int>.create(initialValue: 0)
    defer { v.destroy() }

    v.store(23, ordering: .releasing)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    v.store(42, ordering: .releasing)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)
  }
  func test_Int_store_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int>.create(initialValue: 0)
    defer { v.destroy() }

    v.store(23, ordering: .sequentiallyConsistent)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    v.store(42, ordering: .sequentiallyConsistent)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)
  }

  func test_Int_exchange_relaxed() {
    let v = UnsafeAtomic<Int>.create(initialValue: 0)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(42, ordering: .relaxed), 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)

    XCTAssertEqual(v.exchange(23, ordering: .relaxed), 42)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_Int_exchange_acquiring() {
    let v = UnsafeAtomic<Int>.create(initialValue: 0)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(42, ordering: .acquiring), 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)

    XCTAssertEqual(v.exchange(23, ordering: .acquiring), 42)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_Int_exchange_releasing() {
    let v = UnsafeAtomic<Int>.create(initialValue: 0)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(42, ordering: .releasing), 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)

    XCTAssertEqual(v.exchange(23, ordering: .releasing), 42)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_Int_exchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<Int>.create(initialValue: 0)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(42, ordering: .acquiringAndReleasing), 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)

    XCTAssertEqual(v.exchange(23, ordering: .acquiringAndReleasing), 42)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_Int_exchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int>.create(initialValue: 0)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(42, ordering: .sequentiallyConsistent), 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)

    XCTAssertEqual(v.exchange(23, ordering: .sequentiallyConsistent), 42)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }

  func test_Int_compareExchange_relaxed() {
    let v = UnsafeAtomic<Int>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int_compareExchange_acquiring() {
    let v = UnsafeAtomic<Int>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int_compareExchange_releasing() {
    let v = UnsafeAtomic<Int>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int_compareExchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<Int>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int_compareExchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }

  func test_Int_compareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<Int>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int_compareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<Int>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int_compareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int_compareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<Int>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int_compareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<Int>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int_compareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int_compareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<Int>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int_compareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<Int>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int_compareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int_compareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<Int>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int_compareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<Int>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int_compareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int_compareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<Int>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int_compareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<Int>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int_compareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int_weakCompareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<Int>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int_weakCompareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<Int>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int_weakCompareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int_weakCompareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<Int>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int_weakCompareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<Int>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int_weakCompareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int_weakCompareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<Int>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int_weakCompareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<Int>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int_weakCompareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int_weakCompareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<Int>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int_weakCompareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<Int>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int_weakCompareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<Int>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int_weakCompareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<Int>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }

  func test_Int_loadThenWrappingIncrement_relaxed() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a &+ b
    let result2: Int = result1 &+ c

    let v = UnsafeAtomic<Int>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int_loadThenWrappingIncrement_acquiring() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a &+ b
    let result2: Int = result1 &+ c

    let v = UnsafeAtomic<Int>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int_loadThenWrappingIncrement_releasing() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a &+ b
    let result2: Int = result1 &+ c

    let v = UnsafeAtomic<Int>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int_loadThenWrappingIncrement_acquiringAndReleasing() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a &+ b
    let result2: Int = result1 &+ c

    let v = UnsafeAtomic<Int>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int_loadThenWrappingIncrement_sequentiallyConsistent() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a &+ b
    let result2: Int = result1 &+ c

    let v = UnsafeAtomic<Int>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int_loadThenWrappingDecrement_relaxed() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a &- b
    let result2: Int = result1 &- c

    let v = UnsafeAtomic<Int>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int_loadThenWrappingDecrement_acquiring() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a &- b
    let result2: Int = result1 &- c

    let v = UnsafeAtomic<Int>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int_loadThenWrappingDecrement_releasing() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a &- b
    let result2: Int = result1 &- c

    let v = UnsafeAtomic<Int>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int_loadThenWrappingDecrement_acquiringAndReleasing() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a &- b
    let result2: Int = result1 &- c

    let v = UnsafeAtomic<Int>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int_loadThenWrappingDecrement_sequentiallyConsistent() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a &- b
    let result2: Int = result1 &- c

    let v = UnsafeAtomic<Int>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int_loadThenBitwiseAnd_relaxed() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a & b
    let result2: Int = result1 & c

    let v = UnsafeAtomic<Int>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int_loadThenBitwiseAnd_acquiring() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a & b
    let result2: Int = result1 & c

    let v = UnsafeAtomic<Int>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int_loadThenBitwiseAnd_releasing() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a & b
    let result2: Int = result1 & c

    let v = UnsafeAtomic<Int>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int_loadThenBitwiseAnd_acquiringAndReleasing() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a & b
    let result2: Int = result1 & c

    let v = UnsafeAtomic<Int>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int_loadThenBitwiseAnd_sequentiallyConsistent() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a & b
    let result2: Int = result1 & c

    let v = UnsafeAtomic<Int>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int_loadThenBitwiseOr_relaxed() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a | b
    let result2: Int = result1 | c

    let v = UnsafeAtomic<Int>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int_loadThenBitwiseOr_acquiring() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a | b
    let result2: Int = result1 | c

    let v = UnsafeAtomic<Int>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int_loadThenBitwiseOr_releasing() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a | b
    let result2: Int = result1 | c

    let v = UnsafeAtomic<Int>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int_loadThenBitwiseOr_acquiringAndReleasing() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a | b
    let result2: Int = result1 | c

    let v = UnsafeAtomic<Int>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int_loadThenBitwiseOr_sequentiallyConsistent() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a | b
    let result2: Int = result1 | c

    let v = UnsafeAtomic<Int>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int_loadThenBitwiseXor_relaxed() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a ^ b
    let result2: Int = result1 ^ c

    let v = UnsafeAtomic<Int>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int_loadThenBitwiseXor_acquiring() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a ^ b
    let result2: Int = result1 ^ c

    let v = UnsafeAtomic<Int>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int_loadThenBitwiseXor_releasing() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a ^ b
    let result2: Int = result1 ^ c

    let v = UnsafeAtomic<Int>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int_loadThenBitwiseXor_acquiringAndReleasing() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a ^ b
    let result2: Int = result1 ^ c

    let v = UnsafeAtomic<Int>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int_loadThenBitwiseXor_sequentiallyConsistent() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a ^ b
    let result2: Int = result1 ^ c

    let v = UnsafeAtomic<Int>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }

  func test_Int_wrappingIncrementThenLoad_relaxed() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a &+ b
    let result2: Int = result1 &+ c

    let v = UnsafeAtomic<Int>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int_wrappingIncrementThenLoad_acquiring() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a &+ b
    let result2: Int = result1 &+ c

    let v = UnsafeAtomic<Int>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int_wrappingIncrementThenLoad_releasing() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a &+ b
    let result2: Int = result1 &+ c

    let v = UnsafeAtomic<Int>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int_wrappingIncrementThenLoad_acquiringAndReleasing() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a &+ b
    let result2: Int = result1 &+ c

    let v = UnsafeAtomic<Int>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int_wrappingIncrementThenLoad_sequentiallyConsistent() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a &+ b
    let result2: Int = result1 &+ c

    let v = UnsafeAtomic<Int>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int_wrappingDecrementThenLoad_relaxed() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a &- b
    let result2: Int = result1 &- c

    let v = UnsafeAtomic<Int>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int_wrappingDecrementThenLoad_acquiring() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a &- b
    let result2: Int = result1 &- c

    let v = UnsafeAtomic<Int>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int_wrappingDecrementThenLoad_releasing() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a &- b
    let result2: Int = result1 &- c

    let v = UnsafeAtomic<Int>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int_wrappingDecrementThenLoad_acquiringAndReleasing() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a &- b
    let result2: Int = result1 &- c

    let v = UnsafeAtomic<Int>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int_wrappingDecrementThenLoad_sequentiallyConsistent() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a &- b
    let result2: Int = result1 &- c

    let v = UnsafeAtomic<Int>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int_bitwiseAndThenLoad_relaxed() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a & b
    let result2: Int = result1 & c

    let v = UnsafeAtomic<Int>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int_bitwiseAndThenLoad_acquiring() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a & b
    let result2: Int = result1 & c

    let v = UnsafeAtomic<Int>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int_bitwiseAndThenLoad_releasing() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a & b
    let result2: Int = result1 & c

    let v = UnsafeAtomic<Int>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int_bitwiseAndThenLoad_acquiringAndReleasing() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a & b
    let result2: Int = result1 & c

    let v = UnsafeAtomic<Int>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int_bitwiseAndThenLoad_sequentiallyConsistent() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a & b
    let result2: Int = result1 & c

    let v = UnsafeAtomic<Int>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int_bitwiseOrThenLoad_relaxed() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a | b
    let result2: Int = result1 | c

    let v = UnsafeAtomic<Int>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int_bitwiseOrThenLoad_acquiring() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a | b
    let result2: Int = result1 | c

    let v = UnsafeAtomic<Int>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int_bitwiseOrThenLoad_releasing() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a | b
    let result2: Int = result1 | c

    let v = UnsafeAtomic<Int>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int_bitwiseOrThenLoad_acquiringAndReleasing() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a | b
    let result2: Int = result1 | c

    let v = UnsafeAtomic<Int>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int_bitwiseOrThenLoad_sequentiallyConsistent() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a | b
    let result2: Int = result1 | c

    let v = UnsafeAtomic<Int>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int_bitwiseXorThenLoad_relaxed() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a ^ b
    let result2: Int = result1 ^ c

    let v = UnsafeAtomic<Int>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int_bitwiseXorThenLoad_acquiring() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a ^ b
    let result2: Int = result1 ^ c

    let v = UnsafeAtomic<Int>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int_bitwiseXorThenLoad_releasing() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a ^ b
    let result2: Int = result1 ^ c

    let v = UnsafeAtomic<Int>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int_bitwiseXorThenLoad_acquiringAndReleasing() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a ^ b
    let result2: Int = result1 ^ c

    let v = UnsafeAtomic<Int>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int_bitwiseXorThenLoad_sequentiallyConsistent() {
    let a: Int = 3
    let b: Int = 8
    let c: Int = 12
    let result1: Int = a ^ b
    let result2: Int = result1 ^ c

    let v = UnsafeAtomic<Int>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }


  func test_UInt_create_destroy() {
    let v = UnsafeAtomic<UInt>.create(initialValue: 0)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), 0)

    let w = UnsafeAtomic<UInt>.create(initialValue: 42)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), 42)
  }

  func test_UInt_load_relaxed() {
    let v = UnsafeAtomic<UInt>.create(initialValue: 0)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), 0)

    let w = UnsafeAtomic<UInt>.create(initialValue: 23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), 23)
  }
  func test_UInt_load_acquiring() {
    let v = UnsafeAtomic<UInt>.create(initialValue: 0)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .acquiring), 0)

    let w = UnsafeAtomic<UInt>.create(initialValue: 23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .acquiring), 23)
  }
  func test_UInt_load_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt>.create(initialValue: 0)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .sequentiallyConsistent), 0)

    let w = UnsafeAtomic<UInt>.create(initialValue: 23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .sequentiallyConsistent), 23)
  }

  func test_UInt_store_relaxed() {
    let v = UnsafeAtomic<UInt>.create(initialValue: 0)
    defer { v.destroy() }

    v.store(23, ordering: .relaxed)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    v.store(42, ordering: .relaxed)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)
  }
  func test_UInt_store_releasing() {
    let v = UnsafeAtomic<UInt>.create(initialValue: 0)
    defer { v.destroy() }

    v.store(23, ordering: .releasing)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    v.store(42, ordering: .releasing)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)
  }
  func test_UInt_store_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt>.create(initialValue: 0)
    defer { v.destroy() }

    v.store(23, ordering: .sequentiallyConsistent)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    v.store(42, ordering: .sequentiallyConsistent)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)
  }

  func test_UInt_exchange_relaxed() {
    let v = UnsafeAtomic<UInt>.create(initialValue: 0)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(42, ordering: .relaxed), 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)

    XCTAssertEqual(v.exchange(23, ordering: .relaxed), 42)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_UInt_exchange_acquiring() {
    let v = UnsafeAtomic<UInt>.create(initialValue: 0)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(42, ordering: .acquiring), 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)

    XCTAssertEqual(v.exchange(23, ordering: .acquiring), 42)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_UInt_exchange_releasing() {
    let v = UnsafeAtomic<UInt>.create(initialValue: 0)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(42, ordering: .releasing), 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)

    XCTAssertEqual(v.exchange(23, ordering: .releasing), 42)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_UInt_exchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<UInt>.create(initialValue: 0)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(42, ordering: .acquiringAndReleasing), 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)

    XCTAssertEqual(v.exchange(23, ordering: .acquiringAndReleasing), 42)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_UInt_exchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt>.create(initialValue: 0)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(42, ordering: .sequentiallyConsistent), 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)

    XCTAssertEqual(v.exchange(23, ordering: .sequentiallyConsistent), 42)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }

  func test_UInt_compareExchange_relaxed() {
    let v = UnsafeAtomic<UInt>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt_compareExchange_acquiring() {
    let v = UnsafeAtomic<UInt>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt_compareExchange_releasing() {
    let v = UnsafeAtomic<UInt>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt_compareExchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<UInt>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt_compareExchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }

  func test_UInt_compareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<UInt>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt_compareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<UInt>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt_compareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt_compareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<UInt>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt_compareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<UInt>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt_compareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt_compareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<UInt>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt_compareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<UInt>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt_compareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt_compareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<UInt>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt_compareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<UInt>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt_compareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt_compareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<UInt>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt_compareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<UInt>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt_compareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt_weakCompareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<UInt>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt_weakCompareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<UInt>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt_weakCompareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt_weakCompareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<UInt>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt_weakCompareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<UInt>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt_weakCompareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt_weakCompareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<UInt>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt_weakCompareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<UInt>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt_weakCompareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt_weakCompareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<UInt>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt_weakCompareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<UInt>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt_weakCompareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<UInt>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt_weakCompareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<UInt>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }

  func test_UInt_loadThenWrappingIncrement_relaxed() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a &+ b
    let result2: UInt = result1 &+ c

    let v = UnsafeAtomic<UInt>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt_loadThenWrappingIncrement_acquiring() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a &+ b
    let result2: UInt = result1 &+ c

    let v = UnsafeAtomic<UInt>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt_loadThenWrappingIncrement_releasing() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a &+ b
    let result2: UInt = result1 &+ c

    let v = UnsafeAtomic<UInt>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt_loadThenWrappingIncrement_acquiringAndReleasing() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a &+ b
    let result2: UInt = result1 &+ c

    let v = UnsafeAtomic<UInt>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt_loadThenWrappingIncrement_sequentiallyConsistent() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a &+ b
    let result2: UInt = result1 &+ c

    let v = UnsafeAtomic<UInt>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt_loadThenWrappingDecrement_relaxed() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a &- b
    let result2: UInt = result1 &- c

    let v = UnsafeAtomic<UInt>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt_loadThenWrappingDecrement_acquiring() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a &- b
    let result2: UInt = result1 &- c

    let v = UnsafeAtomic<UInt>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt_loadThenWrappingDecrement_releasing() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a &- b
    let result2: UInt = result1 &- c

    let v = UnsafeAtomic<UInt>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt_loadThenWrappingDecrement_acquiringAndReleasing() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a &- b
    let result2: UInt = result1 &- c

    let v = UnsafeAtomic<UInt>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt_loadThenWrappingDecrement_sequentiallyConsistent() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a &- b
    let result2: UInt = result1 &- c

    let v = UnsafeAtomic<UInt>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt_loadThenBitwiseAnd_relaxed() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a & b
    let result2: UInt = result1 & c

    let v = UnsafeAtomic<UInt>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt_loadThenBitwiseAnd_acquiring() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a & b
    let result2: UInt = result1 & c

    let v = UnsafeAtomic<UInt>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt_loadThenBitwiseAnd_releasing() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a & b
    let result2: UInt = result1 & c

    let v = UnsafeAtomic<UInt>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt_loadThenBitwiseAnd_acquiringAndReleasing() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a & b
    let result2: UInt = result1 & c

    let v = UnsafeAtomic<UInt>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt_loadThenBitwiseAnd_sequentiallyConsistent() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a & b
    let result2: UInt = result1 & c

    let v = UnsafeAtomic<UInt>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt_loadThenBitwiseOr_relaxed() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a | b
    let result2: UInt = result1 | c

    let v = UnsafeAtomic<UInt>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt_loadThenBitwiseOr_acquiring() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a | b
    let result2: UInt = result1 | c

    let v = UnsafeAtomic<UInt>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt_loadThenBitwiseOr_releasing() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a | b
    let result2: UInt = result1 | c

    let v = UnsafeAtomic<UInt>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt_loadThenBitwiseOr_acquiringAndReleasing() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a | b
    let result2: UInt = result1 | c

    let v = UnsafeAtomic<UInt>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt_loadThenBitwiseOr_sequentiallyConsistent() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a | b
    let result2: UInt = result1 | c

    let v = UnsafeAtomic<UInt>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt_loadThenBitwiseXor_relaxed() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a ^ b
    let result2: UInt = result1 ^ c

    let v = UnsafeAtomic<UInt>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt_loadThenBitwiseXor_acquiring() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a ^ b
    let result2: UInt = result1 ^ c

    let v = UnsafeAtomic<UInt>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt_loadThenBitwiseXor_releasing() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a ^ b
    let result2: UInt = result1 ^ c

    let v = UnsafeAtomic<UInt>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt_loadThenBitwiseXor_acquiringAndReleasing() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a ^ b
    let result2: UInt = result1 ^ c

    let v = UnsafeAtomic<UInt>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt_loadThenBitwiseXor_sequentiallyConsistent() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a ^ b
    let result2: UInt = result1 ^ c

    let v = UnsafeAtomic<UInt>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }

  func test_UInt_wrappingIncrementThenLoad_relaxed() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a &+ b
    let result2: UInt = result1 &+ c

    let v = UnsafeAtomic<UInt>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt_wrappingIncrementThenLoad_acquiring() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a &+ b
    let result2: UInt = result1 &+ c

    let v = UnsafeAtomic<UInt>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt_wrappingIncrementThenLoad_releasing() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a &+ b
    let result2: UInt = result1 &+ c

    let v = UnsafeAtomic<UInt>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt_wrappingIncrementThenLoad_acquiringAndReleasing() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a &+ b
    let result2: UInt = result1 &+ c

    let v = UnsafeAtomic<UInt>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt_wrappingIncrementThenLoad_sequentiallyConsistent() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a &+ b
    let result2: UInt = result1 &+ c

    let v = UnsafeAtomic<UInt>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt_wrappingDecrementThenLoad_relaxed() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a &- b
    let result2: UInt = result1 &- c

    let v = UnsafeAtomic<UInt>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt_wrappingDecrementThenLoad_acquiring() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a &- b
    let result2: UInt = result1 &- c

    let v = UnsafeAtomic<UInt>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt_wrappingDecrementThenLoad_releasing() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a &- b
    let result2: UInt = result1 &- c

    let v = UnsafeAtomic<UInt>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt_wrappingDecrementThenLoad_acquiringAndReleasing() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a &- b
    let result2: UInt = result1 &- c

    let v = UnsafeAtomic<UInt>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt_wrappingDecrementThenLoad_sequentiallyConsistent() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a &- b
    let result2: UInt = result1 &- c

    let v = UnsafeAtomic<UInt>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt_bitwiseAndThenLoad_relaxed() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a & b
    let result2: UInt = result1 & c

    let v = UnsafeAtomic<UInt>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt_bitwiseAndThenLoad_acquiring() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a & b
    let result2: UInt = result1 & c

    let v = UnsafeAtomic<UInt>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt_bitwiseAndThenLoad_releasing() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a & b
    let result2: UInt = result1 & c

    let v = UnsafeAtomic<UInt>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt_bitwiseAndThenLoad_acquiringAndReleasing() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a & b
    let result2: UInt = result1 & c

    let v = UnsafeAtomic<UInt>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt_bitwiseAndThenLoad_sequentiallyConsistent() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a & b
    let result2: UInt = result1 & c

    let v = UnsafeAtomic<UInt>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt_bitwiseOrThenLoad_relaxed() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a | b
    let result2: UInt = result1 | c

    let v = UnsafeAtomic<UInt>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt_bitwiseOrThenLoad_acquiring() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a | b
    let result2: UInt = result1 | c

    let v = UnsafeAtomic<UInt>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt_bitwiseOrThenLoad_releasing() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a | b
    let result2: UInt = result1 | c

    let v = UnsafeAtomic<UInt>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt_bitwiseOrThenLoad_acquiringAndReleasing() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a | b
    let result2: UInt = result1 | c

    let v = UnsafeAtomic<UInt>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt_bitwiseOrThenLoad_sequentiallyConsistent() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a | b
    let result2: UInt = result1 | c

    let v = UnsafeAtomic<UInt>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt_bitwiseXorThenLoad_relaxed() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a ^ b
    let result2: UInt = result1 ^ c

    let v = UnsafeAtomic<UInt>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt_bitwiseXorThenLoad_acquiring() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a ^ b
    let result2: UInt = result1 ^ c

    let v = UnsafeAtomic<UInt>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt_bitwiseXorThenLoad_releasing() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a ^ b
    let result2: UInt = result1 ^ c

    let v = UnsafeAtomic<UInt>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt_bitwiseXorThenLoad_acquiringAndReleasing() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a ^ b
    let result2: UInt = result1 ^ c

    let v = UnsafeAtomic<UInt>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt_bitwiseXorThenLoad_sequentiallyConsistent() {
    let a: UInt = 3
    let b: UInt = 8
    let c: UInt = 12
    let result1: UInt = a ^ b
    let result2: UInt = result1 ^ c

    let v = UnsafeAtomic<UInt>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }


  func test_Int64_create_destroy() {
    let v = UnsafeAtomic<Int64>.create(initialValue: 0)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), 0)

    let w = UnsafeAtomic<Int64>.create(initialValue: 42)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), 42)
  }

  func test_Int64_load_relaxed() {
    let v = UnsafeAtomic<Int64>.create(initialValue: 0)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), 0)

    let w = UnsafeAtomic<Int64>.create(initialValue: 23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), 23)
  }
  func test_Int64_load_acquiring() {
    let v = UnsafeAtomic<Int64>.create(initialValue: 0)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .acquiring), 0)

    let w = UnsafeAtomic<Int64>.create(initialValue: 23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .acquiring), 23)
  }
  func test_Int64_load_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int64>.create(initialValue: 0)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .sequentiallyConsistent), 0)

    let w = UnsafeAtomic<Int64>.create(initialValue: 23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .sequentiallyConsistent), 23)
  }

  func test_Int64_store_relaxed() {
    let v = UnsafeAtomic<Int64>.create(initialValue: 0)
    defer { v.destroy() }

    v.store(23, ordering: .relaxed)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    v.store(42, ordering: .relaxed)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)
  }
  func test_Int64_store_releasing() {
    let v = UnsafeAtomic<Int64>.create(initialValue: 0)
    defer { v.destroy() }

    v.store(23, ordering: .releasing)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    v.store(42, ordering: .releasing)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)
  }
  func test_Int64_store_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int64>.create(initialValue: 0)
    defer { v.destroy() }

    v.store(23, ordering: .sequentiallyConsistent)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    v.store(42, ordering: .sequentiallyConsistent)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)
  }

  func test_Int64_exchange_relaxed() {
    let v = UnsafeAtomic<Int64>.create(initialValue: 0)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(42, ordering: .relaxed), 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)

    XCTAssertEqual(v.exchange(23, ordering: .relaxed), 42)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_Int64_exchange_acquiring() {
    let v = UnsafeAtomic<Int64>.create(initialValue: 0)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(42, ordering: .acquiring), 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)

    XCTAssertEqual(v.exchange(23, ordering: .acquiring), 42)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_Int64_exchange_releasing() {
    let v = UnsafeAtomic<Int64>.create(initialValue: 0)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(42, ordering: .releasing), 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)

    XCTAssertEqual(v.exchange(23, ordering: .releasing), 42)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_Int64_exchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<Int64>.create(initialValue: 0)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(42, ordering: .acquiringAndReleasing), 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)

    XCTAssertEqual(v.exchange(23, ordering: .acquiringAndReleasing), 42)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_Int64_exchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int64>.create(initialValue: 0)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(42, ordering: .sequentiallyConsistent), 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)

    XCTAssertEqual(v.exchange(23, ordering: .sequentiallyConsistent), 42)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }

  func test_Int64_compareExchange_relaxed() {
    let v = UnsafeAtomic<Int64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int64_compareExchange_acquiring() {
    let v = UnsafeAtomic<Int64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int64_compareExchange_releasing() {
    let v = UnsafeAtomic<Int64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int64_compareExchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<Int64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int64_compareExchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }

  func test_Int64_compareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<Int64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int64_compareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<Int64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int64_compareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int64_compareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<Int64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int64_compareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<Int64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int64_compareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int64_compareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<Int64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int64_compareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<Int64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int64_compareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int64_compareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<Int64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int64_compareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<Int64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int64_compareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int64_compareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<Int64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int64_compareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<Int64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int64_compareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int64_weakCompareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<Int64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int64_weakCompareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<Int64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int64_weakCompareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int64_weakCompareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<Int64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int64_weakCompareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<Int64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int64_weakCompareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int64_weakCompareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<Int64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int64_weakCompareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<Int64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int64_weakCompareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int64_weakCompareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<Int64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int64_weakCompareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<Int64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int64_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int64_weakCompareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<Int64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int64_weakCompareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<Int64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int64_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }

  func test_Int64_loadThenWrappingIncrement_relaxed() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a &+ b
    let result2: Int64 = result1 &+ c

    let v = UnsafeAtomic<Int64>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int64_loadThenWrappingIncrement_acquiring() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a &+ b
    let result2: Int64 = result1 &+ c

    let v = UnsafeAtomic<Int64>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int64_loadThenWrappingIncrement_releasing() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a &+ b
    let result2: Int64 = result1 &+ c

    let v = UnsafeAtomic<Int64>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int64_loadThenWrappingIncrement_acquiringAndReleasing() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a &+ b
    let result2: Int64 = result1 &+ c

    let v = UnsafeAtomic<Int64>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int64_loadThenWrappingIncrement_sequentiallyConsistent() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a &+ b
    let result2: Int64 = result1 &+ c

    let v = UnsafeAtomic<Int64>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int64_loadThenWrappingDecrement_relaxed() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a &- b
    let result2: Int64 = result1 &- c

    let v = UnsafeAtomic<Int64>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int64_loadThenWrappingDecrement_acquiring() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a &- b
    let result2: Int64 = result1 &- c

    let v = UnsafeAtomic<Int64>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int64_loadThenWrappingDecrement_releasing() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a &- b
    let result2: Int64 = result1 &- c

    let v = UnsafeAtomic<Int64>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int64_loadThenWrappingDecrement_acquiringAndReleasing() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a &- b
    let result2: Int64 = result1 &- c

    let v = UnsafeAtomic<Int64>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int64_loadThenWrappingDecrement_sequentiallyConsistent() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a &- b
    let result2: Int64 = result1 &- c

    let v = UnsafeAtomic<Int64>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int64_loadThenBitwiseAnd_relaxed() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a & b
    let result2: Int64 = result1 & c

    let v = UnsafeAtomic<Int64>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int64_loadThenBitwiseAnd_acquiring() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a & b
    let result2: Int64 = result1 & c

    let v = UnsafeAtomic<Int64>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int64_loadThenBitwiseAnd_releasing() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a & b
    let result2: Int64 = result1 & c

    let v = UnsafeAtomic<Int64>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int64_loadThenBitwiseAnd_acquiringAndReleasing() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a & b
    let result2: Int64 = result1 & c

    let v = UnsafeAtomic<Int64>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int64_loadThenBitwiseAnd_sequentiallyConsistent() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a & b
    let result2: Int64 = result1 & c

    let v = UnsafeAtomic<Int64>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int64_loadThenBitwiseOr_relaxed() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a | b
    let result2: Int64 = result1 | c

    let v = UnsafeAtomic<Int64>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int64_loadThenBitwiseOr_acquiring() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a | b
    let result2: Int64 = result1 | c

    let v = UnsafeAtomic<Int64>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int64_loadThenBitwiseOr_releasing() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a | b
    let result2: Int64 = result1 | c

    let v = UnsafeAtomic<Int64>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int64_loadThenBitwiseOr_acquiringAndReleasing() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a | b
    let result2: Int64 = result1 | c

    let v = UnsafeAtomic<Int64>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int64_loadThenBitwiseOr_sequentiallyConsistent() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a | b
    let result2: Int64 = result1 | c

    let v = UnsafeAtomic<Int64>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int64_loadThenBitwiseXor_relaxed() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a ^ b
    let result2: Int64 = result1 ^ c

    let v = UnsafeAtomic<Int64>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int64_loadThenBitwiseXor_acquiring() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a ^ b
    let result2: Int64 = result1 ^ c

    let v = UnsafeAtomic<Int64>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int64_loadThenBitwiseXor_releasing() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a ^ b
    let result2: Int64 = result1 ^ c

    let v = UnsafeAtomic<Int64>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int64_loadThenBitwiseXor_acquiringAndReleasing() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a ^ b
    let result2: Int64 = result1 ^ c

    let v = UnsafeAtomic<Int64>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int64_loadThenBitwiseXor_sequentiallyConsistent() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a ^ b
    let result2: Int64 = result1 ^ c

    let v = UnsafeAtomic<Int64>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }

  func test_Int64_wrappingIncrementThenLoad_relaxed() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a &+ b
    let result2: Int64 = result1 &+ c

    let v = UnsafeAtomic<Int64>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int64_wrappingIncrementThenLoad_acquiring() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a &+ b
    let result2: Int64 = result1 &+ c

    let v = UnsafeAtomic<Int64>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int64_wrappingIncrementThenLoad_releasing() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a &+ b
    let result2: Int64 = result1 &+ c

    let v = UnsafeAtomic<Int64>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int64_wrappingIncrementThenLoad_acquiringAndReleasing() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a &+ b
    let result2: Int64 = result1 &+ c

    let v = UnsafeAtomic<Int64>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int64_wrappingIncrementThenLoad_sequentiallyConsistent() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a &+ b
    let result2: Int64 = result1 &+ c

    let v = UnsafeAtomic<Int64>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int64_wrappingDecrementThenLoad_relaxed() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a &- b
    let result2: Int64 = result1 &- c

    let v = UnsafeAtomic<Int64>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int64_wrappingDecrementThenLoad_acquiring() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a &- b
    let result2: Int64 = result1 &- c

    let v = UnsafeAtomic<Int64>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int64_wrappingDecrementThenLoad_releasing() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a &- b
    let result2: Int64 = result1 &- c

    let v = UnsafeAtomic<Int64>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int64_wrappingDecrementThenLoad_acquiringAndReleasing() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a &- b
    let result2: Int64 = result1 &- c

    let v = UnsafeAtomic<Int64>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int64_wrappingDecrementThenLoad_sequentiallyConsistent() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a &- b
    let result2: Int64 = result1 &- c

    let v = UnsafeAtomic<Int64>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int64_bitwiseAndThenLoad_relaxed() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a & b
    let result2: Int64 = result1 & c

    let v = UnsafeAtomic<Int64>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int64_bitwiseAndThenLoad_acquiring() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a & b
    let result2: Int64 = result1 & c

    let v = UnsafeAtomic<Int64>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int64_bitwiseAndThenLoad_releasing() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a & b
    let result2: Int64 = result1 & c

    let v = UnsafeAtomic<Int64>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int64_bitwiseAndThenLoad_acquiringAndReleasing() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a & b
    let result2: Int64 = result1 & c

    let v = UnsafeAtomic<Int64>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int64_bitwiseAndThenLoad_sequentiallyConsistent() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a & b
    let result2: Int64 = result1 & c

    let v = UnsafeAtomic<Int64>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int64_bitwiseOrThenLoad_relaxed() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a | b
    let result2: Int64 = result1 | c

    let v = UnsafeAtomic<Int64>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int64_bitwiseOrThenLoad_acquiring() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a | b
    let result2: Int64 = result1 | c

    let v = UnsafeAtomic<Int64>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int64_bitwiseOrThenLoad_releasing() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a | b
    let result2: Int64 = result1 | c

    let v = UnsafeAtomic<Int64>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int64_bitwiseOrThenLoad_acquiringAndReleasing() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a | b
    let result2: Int64 = result1 | c

    let v = UnsafeAtomic<Int64>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int64_bitwiseOrThenLoad_sequentiallyConsistent() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a | b
    let result2: Int64 = result1 | c

    let v = UnsafeAtomic<Int64>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int64_bitwiseXorThenLoad_relaxed() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a ^ b
    let result2: Int64 = result1 ^ c

    let v = UnsafeAtomic<Int64>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int64_bitwiseXorThenLoad_acquiring() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a ^ b
    let result2: Int64 = result1 ^ c

    let v = UnsafeAtomic<Int64>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int64_bitwiseXorThenLoad_releasing() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a ^ b
    let result2: Int64 = result1 ^ c

    let v = UnsafeAtomic<Int64>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int64_bitwiseXorThenLoad_acquiringAndReleasing() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a ^ b
    let result2: Int64 = result1 ^ c

    let v = UnsafeAtomic<Int64>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int64_bitwiseXorThenLoad_sequentiallyConsistent() {
    let a: Int64 = 3
    let b: Int64 = 8
    let c: Int64 = 12
    let result1: Int64 = a ^ b
    let result2: Int64 = result1 ^ c

    let v = UnsafeAtomic<Int64>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }


  func test_UInt64_create_destroy() {
    let v = UnsafeAtomic<UInt64>.create(initialValue: 0)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), 0)

    let w = UnsafeAtomic<UInt64>.create(initialValue: 42)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), 42)
  }

  func test_UInt64_load_relaxed() {
    let v = UnsafeAtomic<UInt64>.create(initialValue: 0)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), 0)

    let w = UnsafeAtomic<UInt64>.create(initialValue: 23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), 23)
  }
  func test_UInt64_load_acquiring() {
    let v = UnsafeAtomic<UInt64>.create(initialValue: 0)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .acquiring), 0)

    let w = UnsafeAtomic<UInt64>.create(initialValue: 23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .acquiring), 23)
  }
  func test_UInt64_load_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt64>.create(initialValue: 0)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .sequentiallyConsistent), 0)

    let w = UnsafeAtomic<UInt64>.create(initialValue: 23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .sequentiallyConsistent), 23)
  }

  func test_UInt64_store_relaxed() {
    let v = UnsafeAtomic<UInt64>.create(initialValue: 0)
    defer { v.destroy() }

    v.store(23, ordering: .relaxed)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    v.store(42, ordering: .relaxed)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)
  }
  func test_UInt64_store_releasing() {
    let v = UnsafeAtomic<UInt64>.create(initialValue: 0)
    defer { v.destroy() }

    v.store(23, ordering: .releasing)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    v.store(42, ordering: .releasing)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)
  }
  func test_UInt64_store_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt64>.create(initialValue: 0)
    defer { v.destroy() }

    v.store(23, ordering: .sequentiallyConsistent)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    v.store(42, ordering: .sequentiallyConsistent)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)
  }

  func test_UInt64_exchange_relaxed() {
    let v = UnsafeAtomic<UInt64>.create(initialValue: 0)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(42, ordering: .relaxed), 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)

    XCTAssertEqual(v.exchange(23, ordering: .relaxed), 42)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_UInt64_exchange_acquiring() {
    let v = UnsafeAtomic<UInt64>.create(initialValue: 0)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(42, ordering: .acquiring), 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)

    XCTAssertEqual(v.exchange(23, ordering: .acquiring), 42)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_UInt64_exchange_releasing() {
    let v = UnsafeAtomic<UInt64>.create(initialValue: 0)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(42, ordering: .releasing), 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)

    XCTAssertEqual(v.exchange(23, ordering: .releasing), 42)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_UInt64_exchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<UInt64>.create(initialValue: 0)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(42, ordering: .acquiringAndReleasing), 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)

    XCTAssertEqual(v.exchange(23, ordering: .acquiringAndReleasing), 42)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_UInt64_exchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt64>.create(initialValue: 0)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(42, ordering: .sequentiallyConsistent), 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)

    XCTAssertEqual(v.exchange(23, ordering: .sequentiallyConsistent), 42)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }

  func test_UInt64_compareExchange_relaxed() {
    let v = UnsafeAtomic<UInt64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt64_compareExchange_acquiring() {
    let v = UnsafeAtomic<UInt64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt64_compareExchange_releasing() {
    let v = UnsafeAtomic<UInt64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt64_compareExchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<UInt64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt64_compareExchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }

  func test_UInt64_compareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<UInt64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt64_compareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<UInt64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt64_compareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt64_compareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<UInt64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt64_compareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<UInt64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt64_compareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt64_compareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<UInt64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt64_compareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<UInt64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt64_compareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt64_compareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<UInt64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt64_compareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<UInt64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt64_compareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt64_compareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<UInt64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt64_compareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<UInt64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt64_compareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt64_weakCompareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<UInt64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt64_weakCompareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<UInt64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt64_weakCompareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt64_weakCompareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<UInt64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt64_weakCompareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<UInt64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt64_weakCompareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt64_weakCompareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<UInt64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt64_weakCompareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<UInt64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt64_weakCompareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt64_weakCompareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<UInt64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt64_weakCompareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<UInt64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt64_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt64_weakCompareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<UInt64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt64_weakCompareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<UInt64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt64_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt64>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }

  func test_UInt64_loadThenWrappingIncrement_relaxed() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a &+ b
    let result2: UInt64 = result1 &+ c

    let v = UnsafeAtomic<UInt64>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt64_loadThenWrappingIncrement_acquiring() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a &+ b
    let result2: UInt64 = result1 &+ c

    let v = UnsafeAtomic<UInt64>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt64_loadThenWrappingIncrement_releasing() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a &+ b
    let result2: UInt64 = result1 &+ c

    let v = UnsafeAtomic<UInt64>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt64_loadThenWrappingIncrement_acquiringAndReleasing() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a &+ b
    let result2: UInt64 = result1 &+ c

    let v = UnsafeAtomic<UInt64>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt64_loadThenWrappingIncrement_sequentiallyConsistent() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a &+ b
    let result2: UInt64 = result1 &+ c

    let v = UnsafeAtomic<UInt64>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt64_loadThenWrappingDecrement_relaxed() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a &- b
    let result2: UInt64 = result1 &- c

    let v = UnsafeAtomic<UInt64>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt64_loadThenWrappingDecrement_acquiring() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a &- b
    let result2: UInt64 = result1 &- c

    let v = UnsafeAtomic<UInt64>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt64_loadThenWrappingDecrement_releasing() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a &- b
    let result2: UInt64 = result1 &- c

    let v = UnsafeAtomic<UInt64>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt64_loadThenWrappingDecrement_acquiringAndReleasing() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a &- b
    let result2: UInt64 = result1 &- c

    let v = UnsafeAtomic<UInt64>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt64_loadThenWrappingDecrement_sequentiallyConsistent() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a &- b
    let result2: UInt64 = result1 &- c

    let v = UnsafeAtomic<UInt64>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt64_loadThenBitwiseAnd_relaxed() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a & b
    let result2: UInt64 = result1 & c

    let v = UnsafeAtomic<UInt64>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt64_loadThenBitwiseAnd_acquiring() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a & b
    let result2: UInt64 = result1 & c

    let v = UnsafeAtomic<UInt64>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt64_loadThenBitwiseAnd_releasing() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a & b
    let result2: UInt64 = result1 & c

    let v = UnsafeAtomic<UInt64>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt64_loadThenBitwiseAnd_acquiringAndReleasing() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a & b
    let result2: UInt64 = result1 & c

    let v = UnsafeAtomic<UInt64>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt64_loadThenBitwiseAnd_sequentiallyConsistent() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a & b
    let result2: UInt64 = result1 & c

    let v = UnsafeAtomic<UInt64>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt64_loadThenBitwiseOr_relaxed() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a | b
    let result2: UInt64 = result1 | c

    let v = UnsafeAtomic<UInt64>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt64_loadThenBitwiseOr_acquiring() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a | b
    let result2: UInt64 = result1 | c

    let v = UnsafeAtomic<UInt64>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt64_loadThenBitwiseOr_releasing() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a | b
    let result2: UInt64 = result1 | c

    let v = UnsafeAtomic<UInt64>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt64_loadThenBitwiseOr_acquiringAndReleasing() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a | b
    let result2: UInt64 = result1 | c

    let v = UnsafeAtomic<UInt64>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt64_loadThenBitwiseOr_sequentiallyConsistent() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a | b
    let result2: UInt64 = result1 | c

    let v = UnsafeAtomic<UInt64>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt64_loadThenBitwiseXor_relaxed() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a ^ b
    let result2: UInt64 = result1 ^ c

    let v = UnsafeAtomic<UInt64>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt64_loadThenBitwiseXor_acquiring() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a ^ b
    let result2: UInt64 = result1 ^ c

    let v = UnsafeAtomic<UInt64>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt64_loadThenBitwiseXor_releasing() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a ^ b
    let result2: UInt64 = result1 ^ c

    let v = UnsafeAtomic<UInt64>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt64_loadThenBitwiseXor_acquiringAndReleasing() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a ^ b
    let result2: UInt64 = result1 ^ c

    let v = UnsafeAtomic<UInt64>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt64_loadThenBitwiseXor_sequentiallyConsistent() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a ^ b
    let result2: UInt64 = result1 ^ c

    let v = UnsafeAtomic<UInt64>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }

  func test_UInt64_wrappingIncrementThenLoad_relaxed() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a &+ b
    let result2: UInt64 = result1 &+ c

    let v = UnsafeAtomic<UInt64>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt64_wrappingIncrementThenLoad_acquiring() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a &+ b
    let result2: UInt64 = result1 &+ c

    let v = UnsafeAtomic<UInt64>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt64_wrappingIncrementThenLoad_releasing() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a &+ b
    let result2: UInt64 = result1 &+ c

    let v = UnsafeAtomic<UInt64>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt64_wrappingIncrementThenLoad_acquiringAndReleasing() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a &+ b
    let result2: UInt64 = result1 &+ c

    let v = UnsafeAtomic<UInt64>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt64_wrappingIncrementThenLoad_sequentiallyConsistent() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a &+ b
    let result2: UInt64 = result1 &+ c

    let v = UnsafeAtomic<UInt64>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt64_wrappingDecrementThenLoad_relaxed() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a &- b
    let result2: UInt64 = result1 &- c

    let v = UnsafeAtomic<UInt64>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt64_wrappingDecrementThenLoad_acquiring() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a &- b
    let result2: UInt64 = result1 &- c

    let v = UnsafeAtomic<UInt64>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt64_wrappingDecrementThenLoad_releasing() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a &- b
    let result2: UInt64 = result1 &- c

    let v = UnsafeAtomic<UInt64>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt64_wrappingDecrementThenLoad_acquiringAndReleasing() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a &- b
    let result2: UInt64 = result1 &- c

    let v = UnsafeAtomic<UInt64>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt64_wrappingDecrementThenLoad_sequentiallyConsistent() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a &- b
    let result2: UInt64 = result1 &- c

    let v = UnsafeAtomic<UInt64>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt64_bitwiseAndThenLoad_relaxed() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a & b
    let result2: UInt64 = result1 & c

    let v = UnsafeAtomic<UInt64>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt64_bitwiseAndThenLoad_acquiring() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a & b
    let result2: UInt64 = result1 & c

    let v = UnsafeAtomic<UInt64>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt64_bitwiseAndThenLoad_releasing() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a & b
    let result2: UInt64 = result1 & c

    let v = UnsafeAtomic<UInt64>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt64_bitwiseAndThenLoad_acquiringAndReleasing() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a & b
    let result2: UInt64 = result1 & c

    let v = UnsafeAtomic<UInt64>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt64_bitwiseAndThenLoad_sequentiallyConsistent() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a & b
    let result2: UInt64 = result1 & c

    let v = UnsafeAtomic<UInt64>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt64_bitwiseOrThenLoad_relaxed() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a | b
    let result2: UInt64 = result1 | c

    let v = UnsafeAtomic<UInt64>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt64_bitwiseOrThenLoad_acquiring() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a | b
    let result2: UInt64 = result1 | c

    let v = UnsafeAtomic<UInt64>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt64_bitwiseOrThenLoad_releasing() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a | b
    let result2: UInt64 = result1 | c

    let v = UnsafeAtomic<UInt64>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt64_bitwiseOrThenLoad_acquiringAndReleasing() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a | b
    let result2: UInt64 = result1 | c

    let v = UnsafeAtomic<UInt64>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt64_bitwiseOrThenLoad_sequentiallyConsistent() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a | b
    let result2: UInt64 = result1 | c

    let v = UnsafeAtomic<UInt64>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt64_bitwiseXorThenLoad_relaxed() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a ^ b
    let result2: UInt64 = result1 ^ c

    let v = UnsafeAtomic<UInt64>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt64_bitwiseXorThenLoad_acquiring() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a ^ b
    let result2: UInt64 = result1 ^ c

    let v = UnsafeAtomic<UInt64>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt64_bitwiseXorThenLoad_releasing() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a ^ b
    let result2: UInt64 = result1 ^ c

    let v = UnsafeAtomic<UInt64>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt64_bitwiseXorThenLoad_acquiringAndReleasing() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a ^ b
    let result2: UInt64 = result1 ^ c

    let v = UnsafeAtomic<UInt64>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt64_bitwiseXorThenLoad_sequentiallyConsistent() {
    let a: UInt64 = 3
    let b: UInt64 = 8
    let c: UInt64 = 12
    let result1: UInt64 = a ^ b
    let result2: UInt64 = result1 ^ c

    let v = UnsafeAtomic<UInt64>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }


  func test_Int32_create_destroy() {
    let v = UnsafeAtomic<Int32>.create(initialValue: 0)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), 0)

    let w = UnsafeAtomic<Int32>.create(initialValue: 42)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), 42)
  }

  func test_Int32_load_relaxed() {
    let v = UnsafeAtomic<Int32>.create(initialValue: 0)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), 0)

    let w = UnsafeAtomic<Int32>.create(initialValue: 23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), 23)
  }
  func test_Int32_load_acquiring() {
    let v = UnsafeAtomic<Int32>.create(initialValue: 0)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .acquiring), 0)

    let w = UnsafeAtomic<Int32>.create(initialValue: 23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .acquiring), 23)
  }
  func test_Int32_load_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int32>.create(initialValue: 0)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .sequentiallyConsistent), 0)

    let w = UnsafeAtomic<Int32>.create(initialValue: 23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .sequentiallyConsistent), 23)
  }

  func test_Int32_store_relaxed() {
    let v = UnsafeAtomic<Int32>.create(initialValue: 0)
    defer { v.destroy() }

    v.store(23, ordering: .relaxed)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    v.store(42, ordering: .relaxed)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)
  }
  func test_Int32_store_releasing() {
    let v = UnsafeAtomic<Int32>.create(initialValue: 0)
    defer { v.destroy() }

    v.store(23, ordering: .releasing)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    v.store(42, ordering: .releasing)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)
  }
  func test_Int32_store_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int32>.create(initialValue: 0)
    defer { v.destroy() }

    v.store(23, ordering: .sequentiallyConsistent)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    v.store(42, ordering: .sequentiallyConsistent)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)
  }

  func test_Int32_exchange_relaxed() {
    let v = UnsafeAtomic<Int32>.create(initialValue: 0)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(42, ordering: .relaxed), 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)

    XCTAssertEqual(v.exchange(23, ordering: .relaxed), 42)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_Int32_exchange_acquiring() {
    let v = UnsafeAtomic<Int32>.create(initialValue: 0)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(42, ordering: .acquiring), 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)

    XCTAssertEqual(v.exchange(23, ordering: .acquiring), 42)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_Int32_exchange_releasing() {
    let v = UnsafeAtomic<Int32>.create(initialValue: 0)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(42, ordering: .releasing), 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)

    XCTAssertEqual(v.exchange(23, ordering: .releasing), 42)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_Int32_exchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<Int32>.create(initialValue: 0)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(42, ordering: .acquiringAndReleasing), 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)

    XCTAssertEqual(v.exchange(23, ordering: .acquiringAndReleasing), 42)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_Int32_exchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int32>.create(initialValue: 0)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(42, ordering: .sequentiallyConsistent), 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)

    XCTAssertEqual(v.exchange(23, ordering: .sequentiallyConsistent), 42)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }

  func test_Int32_compareExchange_relaxed() {
    let v = UnsafeAtomic<Int32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int32_compareExchange_acquiring() {
    let v = UnsafeAtomic<Int32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int32_compareExchange_releasing() {
    let v = UnsafeAtomic<Int32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int32_compareExchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<Int32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int32_compareExchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }

  func test_Int32_compareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<Int32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int32_compareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<Int32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int32_compareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int32_compareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<Int32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int32_compareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<Int32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int32_compareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int32_compareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<Int32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int32_compareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<Int32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int32_compareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int32_compareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<Int32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int32_compareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<Int32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int32_compareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int32_compareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<Int32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int32_compareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<Int32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int32_compareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int32_weakCompareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<Int32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int32_weakCompareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<Int32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int32_weakCompareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int32_weakCompareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<Int32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int32_weakCompareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<Int32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int32_weakCompareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int32_weakCompareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<Int32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int32_weakCompareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<Int32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int32_weakCompareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int32_weakCompareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<Int32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int32_weakCompareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<Int32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int32_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int32_weakCompareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<Int32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int32_weakCompareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<Int32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int32_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }

  func test_Int32_loadThenWrappingIncrement_relaxed() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a &+ b
    let result2: Int32 = result1 &+ c

    let v = UnsafeAtomic<Int32>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int32_loadThenWrappingIncrement_acquiring() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a &+ b
    let result2: Int32 = result1 &+ c

    let v = UnsafeAtomic<Int32>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int32_loadThenWrappingIncrement_releasing() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a &+ b
    let result2: Int32 = result1 &+ c

    let v = UnsafeAtomic<Int32>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int32_loadThenWrappingIncrement_acquiringAndReleasing() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a &+ b
    let result2: Int32 = result1 &+ c

    let v = UnsafeAtomic<Int32>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int32_loadThenWrappingIncrement_sequentiallyConsistent() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a &+ b
    let result2: Int32 = result1 &+ c

    let v = UnsafeAtomic<Int32>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int32_loadThenWrappingDecrement_relaxed() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a &- b
    let result2: Int32 = result1 &- c

    let v = UnsafeAtomic<Int32>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int32_loadThenWrappingDecrement_acquiring() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a &- b
    let result2: Int32 = result1 &- c

    let v = UnsafeAtomic<Int32>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int32_loadThenWrappingDecrement_releasing() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a &- b
    let result2: Int32 = result1 &- c

    let v = UnsafeAtomic<Int32>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int32_loadThenWrappingDecrement_acquiringAndReleasing() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a &- b
    let result2: Int32 = result1 &- c

    let v = UnsafeAtomic<Int32>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int32_loadThenWrappingDecrement_sequentiallyConsistent() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a &- b
    let result2: Int32 = result1 &- c

    let v = UnsafeAtomic<Int32>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int32_loadThenBitwiseAnd_relaxed() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a & b
    let result2: Int32 = result1 & c

    let v = UnsafeAtomic<Int32>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int32_loadThenBitwiseAnd_acquiring() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a & b
    let result2: Int32 = result1 & c

    let v = UnsafeAtomic<Int32>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int32_loadThenBitwiseAnd_releasing() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a & b
    let result2: Int32 = result1 & c

    let v = UnsafeAtomic<Int32>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int32_loadThenBitwiseAnd_acquiringAndReleasing() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a & b
    let result2: Int32 = result1 & c

    let v = UnsafeAtomic<Int32>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int32_loadThenBitwiseAnd_sequentiallyConsistent() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a & b
    let result2: Int32 = result1 & c

    let v = UnsafeAtomic<Int32>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int32_loadThenBitwiseOr_relaxed() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a | b
    let result2: Int32 = result1 | c

    let v = UnsafeAtomic<Int32>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int32_loadThenBitwiseOr_acquiring() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a | b
    let result2: Int32 = result1 | c

    let v = UnsafeAtomic<Int32>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int32_loadThenBitwiseOr_releasing() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a | b
    let result2: Int32 = result1 | c

    let v = UnsafeAtomic<Int32>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int32_loadThenBitwiseOr_acquiringAndReleasing() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a | b
    let result2: Int32 = result1 | c

    let v = UnsafeAtomic<Int32>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int32_loadThenBitwiseOr_sequentiallyConsistent() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a | b
    let result2: Int32 = result1 | c

    let v = UnsafeAtomic<Int32>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int32_loadThenBitwiseXor_relaxed() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a ^ b
    let result2: Int32 = result1 ^ c

    let v = UnsafeAtomic<Int32>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int32_loadThenBitwiseXor_acquiring() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a ^ b
    let result2: Int32 = result1 ^ c

    let v = UnsafeAtomic<Int32>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int32_loadThenBitwiseXor_releasing() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a ^ b
    let result2: Int32 = result1 ^ c

    let v = UnsafeAtomic<Int32>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int32_loadThenBitwiseXor_acquiringAndReleasing() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a ^ b
    let result2: Int32 = result1 ^ c

    let v = UnsafeAtomic<Int32>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int32_loadThenBitwiseXor_sequentiallyConsistent() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a ^ b
    let result2: Int32 = result1 ^ c

    let v = UnsafeAtomic<Int32>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }

  func test_Int32_wrappingIncrementThenLoad_relaxed() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a &+ b
    let result2: Int32 = result1 &+ c

    let v = UnsafeAtomic<Int32>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int32_wrappingIncrementThenLoad_acquiring() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a &+ b
    let result2: Int32 = result1 &+ c

    let v = UnsafeAtomic<Int32>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int32_wrappingIncrementThenLoad_releasing() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a &+ b
    let result2: Int32 = result1 &+ c

    let v = UnsafeAtomic<Int32>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int32_wrappingIncrementThenLoad_acquiringAndReleasing() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a &+ b
    let result2: Int32 = result1 &+ c

    let v = UnsafeAtomic<Int32>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int32_wrappingIncrementThenLoad_sequentiallyConsistent() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a &+ b
    let result2: Int32 = result1 &+ c

    let v = UnsafeAtomic<Int32>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int32_wrappingDecrementThenLoad_relaxed() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a &- b
    let result2: Int32 = result1 &- c

    let v = UnsafeAtomic<Int32>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int32_wrappingDecrementThenLoad_acquiring() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a &- b
    let result2: Int32 = result1 &- c

    let v = UnsafeAtomic<Int32>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int32_wrappingDecrementThenLoad_releasing() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a &- b
    let result2: Int32 = result1 &- c

    let v = UnsafeAtomic<Int32>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int32_wrappingDecrementThenLoad_acquiringAndReleasing() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a &- b
    let result2: Int32 = result1 &- c

    let v = UnsafeAtomic<Int32>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int32_wrappingDecrementThenLoad_sequentiallyConsistent() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a &- b
    let result2: Int32 = result1 &- c

    let v = UnsafeAtomic<Int32>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int32_bitwiseAndThenLoad_relaxed() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a & b
    let result2: Int32 = result1 & c

    let v = UnsafeAtomic<Int32>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int32_bitwiseAndThenLoad_acquiring() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a & b
    let result2: Int32 = result1 & c

    let v = UnsafeAtomic<Int32>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int32_bitwiseAndThenLoad_releasing() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a & b
    let result2: Int32 = result1 & c

    let v = UnsafeAtomic<Int32>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int32_bitwiseAndThenLoad_acquiringAndReleasing() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a & b
    let result2: Int32 = result1 & c

    let v = UnsafeAtomic<Int32>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int32_bitwiseAndThenLoad_sequentiallyConsistent() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a & b
    let result2: Int32 = result1 & c

    let v = UnsafeAtomic<Int32>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int32_bitwiseOrThenLoad_relaxed() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a | b
    let result2: Int32 = result1 | c

    let v = UnsafeAtomic<Int32>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int32_bitwiseOrThenLoad_acquiring() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a | b
    let result2: Int32 = result1 | c

    let v = UnsafeAtomic<Int32>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int32_bitwiseOrThenLoad_releasing() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a | b
    let result2: Int32 = result1 | c

    let v = UnsafeAtomic<Int32>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int32_bitwiseOrThenLoad_acquiringAndReleasing() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a | b
    let result2: Int32 = result1 | c

    let v = UnsafeAtomic<Int32>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int32_bitwiseOrThenLoad_sequentiallyConsistent() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a | b
    let result2: Int32 = result1 | c

    let v = UnsafeAtomic<Int32>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int32_bitwiseXorThenLoad_relaxed() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a ^ b
    let result2: Int32 = result1 ^ c

    let v = UnsafeAtomic<Int32>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int32_bitwiseXorThenLoad_acquiring() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a ^ b
    let result2: Int32 = result1 ^ c

    let v = UnsafeAtomic<Int32>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int32_bitwiseXorThenLoad_releasing() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a ^ b
    let result2: Int32 = result1 ^ c

    let v = UnsafeAtomic<Int32>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int32_bitwiseXorThenLoad_acquiringAndReleasing() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a ^ b
    let result2: Int32 = result1 ^ c

    let v = UnsafeAtomic<Int32>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int32_bitwiseXorThenLoad_sequentiallyConsistent() {
    let a: Int32 = 3
    let b: Int32 = 8
    let c: Int32 = 12
    let result1: Int32 = a ^ b
    let result2: Int32 = result1 ^ c

    let v = UnsafeAtomic<Int32>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }


  func test_UInt32_create_destroy() {
    let v = UnsafeAtomic<UInt32>.create(initialValue: 0)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), 0)

    let w = UnsafeAtomic<UInt32>.create(initialValue: 42)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), 42)
  }

  func test_UInt32_load_relaxed() {
    let v = UnsafeAtomic<UInt32>.create(initialValue: 0)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), 0)

    let w = UnsafeAtomic<UInt32>.create(initialValue: 23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), 23)
  }
  func test_UInt32_load_acquiring() {
    let v = UnsafeAtomic<UInt32>.create(initialValue: 0)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .acquiring), 0)

    let w = UnsafeAtomic<UInt32>.create(initialValue: 23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .acquiring), 23)
  }
  func test_UInt32_load_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt32>.create(initialValue: 0)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .sequentiallyConsistent), 0)

    let w = UnsafeAtomic<UInt32>.create(initialValue: 23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .sequentiallyConsistent), 23)
  }

  func test_UInt32_store_relaxed() {
    let v = UnsafeAtomic<UInt32>.create(initialValue: 0)
    defer { v.destroy() }

    v.store(23, ordering: .relaxed)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    v.store(42, ordering: .relaxed)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)
  }
  func test_UInt32_store_releasing() {
    let v = UnsafeAtomic<UInt32>.create(initialValue: 0)
    defer { v.destroy() }

    v.store(23, ordering: .releasing)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    v.store(42, ordering: .releasing)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)
  }
  func test_UInt32_store_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt32>.create(initialValue: 0)
    defer { v.destroy() }

    v.store(23, ordering: .sequentiallyConsistent)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    v.store(42, ordering: .sequentiallyConsistent)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)
  }

  func test_UInt32_exchange_relaxed() {
    let v = UnsafeAtomic<UInt32>.create(initialValue: 0)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(42, ordering: .relaxed), 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)

    XCTAssertEqual(v.exchange(23, ordering: .relaxed), 42)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_UInt32_exchange_acquiring() {
    let v = UnsafeAtomic<UInt32>.create(initialValue: 0)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(42, ordering: .acquiring), 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)

    XCTAssertEqual(v.exchange(23, ordering: .acquiring), 42)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_UInt32_exchange_releasing() {
    let v = UnsafeAtomic<UInt32>.create(initialValue: 0)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(42, ordering: .releasing), 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)

    XCTAssertEqual(v.exchange(23, ordering: .releasing), 42)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_UInt32_exchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<UInt32>.create(initialValue: 0)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(42, ordering: .acquiringAndReleasing), 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)

    XCTAssertEqual(v.exchange(23, ordering: .acquiringAndReleasing), 42)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_UInt32_exchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt32>.create(initialValue: 0)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(42, ordering: .sequentiallyConsistent), 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)

    XCTAssertEqual(v.exchange(23, ordering: .sequentiallyConsistent), 42)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }

  func test_UInt32_compareExchange_relaxed() {
    let v = UnsafeAtomic<UInt32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt32_compareExchange_acquiring() {
    let v = UnsafeAtomic<UInt32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt32_compareExchange_releasing() {
    let v = UnsafeAtomic<UInt32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt32_compareExchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<UInt32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt32_compareExchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }

  func test_UInt32_compareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<UInt32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt32_compareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<UInt32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt32_compareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt32_compareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<UInt32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt32_compareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<UInt32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt32_compareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt32_compareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<UInt32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt32_compareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<UInt32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt32_compareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt32_compareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<UInt32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt32_compareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<UInt32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt32_compareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt32_compareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<UInt32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt32_compareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<UInt32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt32_compareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt32_weakCompareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<UInt32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt32_weakCompareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<UInt32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt32_weakCompareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt32_weakCompareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<UInt32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt32_weakCompareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<UInt32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt32_weakCompareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt32_weakCompareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<UInt32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt32_weakCompareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<UInt32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt32_weakCompareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt32_weakCompareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<UInt32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt32_weakCompareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<UInt32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt32_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt32_weakCompareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<UInt32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt32_weakCompareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<UInt32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt32_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt32>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }

  func test_UInt32_loadThenWrappingIncrement_relaxed() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a &+ b
    let result2: UInt32 = result1 &+ c

    let v = UnsafeAtomic<UInt32>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt32_loadThenWrappingIncrement_acquiring() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a &+ b
    let result2: UInt32 = result1 &+ c

    let v = UnsafeAtomic<UInt32>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt32_loadThenWrappingIncrement_releasing() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a &+ b
    let result2: UInt32 = result1 &+ c

    let v = UnsafeAtomic<UInt32>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt32_loadThenWrappingIncrement_acquiringAndReleasing() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a &+ b
    let result2: UInt32 = result1 &+ c

    let v = UnsafeAtomic<UInt32>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt32_loadThenWrappingIncrement_sequentiallyConsistent() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a &+ b
    let result2: UInt32 = result1 &+ c

    let v = UnsafeAtomic<UInt32>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt32_loadThenWrappingDecrement_relaxed() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a &- b
    let result2: UInt32 = result1 &- c

    let v = UnsafeAtomic<UInt32>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt32_loadThenWrappingDecrement_acquiring() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a &- b
    let result2: UInt32 = result1 &- c

    let v = UnsafeAtomic<UInt32>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt32_loadThenWrappingDecrement_releasing() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a &- b
    let result2: UInt32 = result1 &- c

    let v = UnsafeAtomic<UInt32>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt32_loadThenWrappingDecrement_acquiringAndReleasing() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a &- b
    let result2: UInt32 = result1 &- c

    let v = UnsafeAtomic<UInt32>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt32_loadThenWrappingDecrement_sequentiallyConsistent() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a &- b
    let result2: UInt32 = result1 &- c

    let v = UnsafeAtomic<UInt32>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt32_loadThenBitwiseAnd_relaxed() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a & b
    let result2: UInt32 = result1 & c

    let v = UnsafeAtomic<UInt32>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt32_loadThenBitwiseAnd_acquiring() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a & b
    let result2: UInt32 = result1 & c

    let v = UnsafeAtomic<UInt32>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt32_loadThenBitwiseAnd_releasing() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a & b
    let result2: UInt32 = result1 & c

    let v = UnsafeAtomic<UInt32>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt32_loadThenBitwiseAnd_acquiringAndReleasing() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a & b
    let result2: UInt32 = result1 & c

    let v = UnsafeAtomic<UInt32>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt32_loadThenBitwiseAnd_sequentiallyConsistent() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a & b
    let result2: UInt32 = result1 & c

    let v = UnsafeAtomic<UInt32>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt32_loadThenBitwiseOr_relaxed() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a | b
    let result2: UInt32 = result1 | c

    let v = UnsafeAtomic<UInt32>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt32_loadThenBitwiseOr_acquiring() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a | b
    let result2: UInt32 = result1 | c

    let v = UnsafeAtomic<UInt32>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt32_loadThenBitwiseOr_releasing() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a | b
    let result2: UInt32 = result1 | c

    let v = UnsafeAtomic<UInt32>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt32_loadThenBitwiseOr_acquiringAndReleasing() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a | b
    let result2: UInt32 = result1 | c

    let v = UnsafeAtomic<UInt32>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt32_loadThenBitwiseOr_sequentiallyConsistent() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a | b
    let result2: UInt32 = result1 | c

    let v = UnsafeAtomic<UInt32>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt32_loadThenBitwiseXor_relaxed() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a ^ b
    let result2: UInt32 = result1 ^ c

    let v = UnsafeAtomic<UInt32>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt32_loadThenBitwiseXor_acquiring() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a ^ b
    let result2: UInt32 = result1 ^ c

    let v = UnsafeAtomic<UInt32>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt32_loadThenBitwiseXor_releasing() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a ^ b
    let result2: UInt32 = result1 ^ c

    let v = UnsafeAtomic<UInt32>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt32_loadThenBitwiseXor_acquiringAndReleasing() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a ^ b
    let result2: UInt32 = result1 ^ c

    let v = UnsafeAtomic<UInt32>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt32_loadThenBitwiseXor_sequentiallyConsistent() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a ^ b
    let result2: UInt32 = result1 ^ c

    let v = UnsafeAtomic<UInt32>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }

  func test_UInt32_wrappingIncrementThenLoad_relaxed() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a &+ b
    let result2: UInt32 = result1 &+ c

    let v = UnsafeAtomic<UInt32>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt32_wrappingIncrementThenLoad_acquiring() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a &+ b
    let result2: UInt32 = result1 &+ c

    let v = UnsafeAtomic<UInt32>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt32_wrappingIncrementThenLoad_releasing() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a &+ b
    let result2: UInt32 = result1 &+ c

    let v = UnsafeAtomic<UInt32>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt32_wrappingIncrementThenLoad_acquiringAndReleasing() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a &+ b
    let result2: UInt32 = result1 &+ c

    let v = UnsafeAtomic<UInt32>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt32_wrappingIncrementThenLoad_sequentiallyConsistent() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a &+ b
    let result2: UInt32 = result1 &+ c

    let v = UnsafeAtomic<UInt32>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt32_wrappingDecrementThenLoad_relaxed() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a &- b
    let result2: UInt32 = result1 &- c

    let v = UnsafeAtomic<UInt32>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt32_wrappingDecrementThenLoad_acquiring() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a &- b
    let result2: UInt32 = result1 &- c

    let v = UnsafeAtomic<UInt32>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt32_wrappingDecrementThenLoad_releasing() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a &- b
    let result2: UInt32 = result1 &- c

    let v = UnsafeAtomic<UInt32>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt32_wrappingDecrementThenLoad_acquiringAndReleasing() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a &- b
    let result2: UInt32 = result1 &- c

    let v = UnsafeAtomic<UInt32>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt32_wrappingDecrementThenLoad_sequentiallyConsistent() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a &- b
    let result2: UInt32 = result1 &- c

    let v = UnsafeAtomic<UInt32>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt32_bitwiseAndThenLoad_relaxed() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a & b
    let result2: UInt32 = result1 & c

    let v = UnsafeAtomic<UInt32>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt32_bitwiseAndThenLoad_acquiring() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a & b
    let result2: UInt32 = result1 & c

    let v = UnsafeAtomic<UInt32>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt32_bitwiseAndThenLoad_releasing() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a & b
    let result2: UInt32 = result1 & c

    let v = UnsafeAtomic<UInt32>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt32_bitwiseAndThenLoad_acquiringAndReleasing() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a & b
    let result2: UInt32 = result1 & c

    let v = UnsafeAtomic<UInt32>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt32_bitwiseAndThenLoad_sequentiallyConsistent() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a & b
    let result2: UInt32 = result1 & c

    let v = UnsafeAtomic<UInt32>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt32_bitwiseOrThenLoad_relaxed() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a | b
    let result2: UInt32 = result1 | c

    let v = UnsafeAtomic<UInt32>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt32_bitwiseOrThenLoad_acquiring() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a | b
    let result2: UInt32 = result1 | c

    let v = UnsafeAtomic<UInt32>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt32_bitwiseOrThenLoad_releasing() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a | b
    let result2: UInt32 = result1 | c

    let v = UnsafeAtomic<UInt32>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt32_bitwiseOrThenLoad_acquiringAndReleasing() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a | b
    let result2: UInt32 = result1 | c

    let v = UnsafeAtomic<UInt32>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt32_bitwiseOrThenLoad_sequentiallyConsistent() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a | b
    let result2: UInt32 = result1 | c

    let v = UnsafeAtomic<UInt32>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt32_bitwiseXorThenLoad_relaxed() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a ^ b
    let result2: UInt32 = result1 ^ c

    let v = UnsafeAtomic<UInt32>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt32_bitwiseXorThenLoad_acquiring() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a ^ b
    let result2: UInt32 = result1 ^ c

    let v = UnsafeAtomic<UInt32>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt32_bitwiseXorThenLoad_releasing() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a ^ b
    let result2: UInt32 = result1 ^ c

    let v = UnsafeAtomic<UInt32>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt32_bitwiseXorThenLoad_acquiringAndReleasing() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a ^ b
    let result2: UInt32 = result1 ^ c

    let v = UnsafeAtomic<UInt32>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt32_bitwiseXorThenLoad_sequentiallyConsistent() {
    let a: UInt32 = 3
    let b: UInt32 = 8
    let c: UInt32 = 12
    let result1: UInt32 = a ^ b
    let result2: UInt32 = result1 ^ c

    let v = UnsafeAtomic<UInt32>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }


  func test_Int16_create_destroy() {
    let v = UnsafeAtomic<Int16>.create(initialValue: 0)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), 0)

    let w = UnsafeAtomic<Int16>.create(initialValue: 42)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), 42)
  }

  func test_Int16_load_relaxed() {
    let v = UnsafeAtomic<Int16>.create(initialValue: 0)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), 0)

    let w = UnsafeAtomic<Int16>.create(initialValue: 23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), 23)
  }
  func test_Int16_load_acquiring() {
    let v = UnsafeAtomic<Int16>.create(initialValue: 0)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .acquiring), 0)

    let w = UnsafeAtomic<Int16>.create(initialValue: 23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .acquiring), 23)
  }
  func test_Int16_load_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int16>.create(initialValue: 0)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .sequentiallyConsistent), 0)

    let w = UnsafeAtomic<Int16>.create(initialValue: 23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .sequentiallyConsistent), 23)
  }

  func test_Int16_store_relaxed() {
    let v = UnsafeAtomic<Int16>.create(initialValue: 0)
    defer { v.destroy() }

    v.store(23, ordering: .relaxed)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    v.store(42, ordering: .relaxed)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)
  }
  func test_Int16_store_releasing() {
    let v = UnsafeAtomic<Int16>.create(initialValue: 0)
    defer { v.destroy() }

    v.store(23, ordering: .releasing)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    v.store(42, ordering: .releasing)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)
  }
  func test_Int16_store_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int16>.create(initialValue: 0)
    defer { v.destroy() }

    v.store(23, ordering: .sequentiallyConsistent)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    v.store(42, ordering: .sequentiallyConsistent)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)
  }

  func test_Int16_exchange_relaxed() {
    let v = UnsafeAtomic<Int16>.create(initialValue: 0)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(42, ordering: .relaxed), 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)

    XCTAssertEqual(v.exchange(23, ordering: .relaxed), 42)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_Int16_exchange_acquiring() {
    let v = UnsafeAtomic<Int16>.create(initialValue: 0)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(42, ordering: .acquiring), 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)

    XCTAssertEqual(v.exchange(23, ordering: .acquiring), 42)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_Int16_exchange_releasing() {
    let v = UnsafeAtomic<Int16>.create(initialValue: 0)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(42, ordering: .releasing), 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)

    XCTAssertEqual(v.exchange(23, ordering: .releasing), 42)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_Int16_exchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<Int16>.create(initialValue: 0)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(42, ordering: .acquiringAndReleasing), 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)

    XCTAssertEqual(v.exchange(23, ordering: .acquiringAndReleasing), 42)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_Int16_exchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int16>.create(initialValue: 0)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(42, ordering: .sequentiallyConsistent), 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)

    XCTAssertEqual(v.exchange(23, ordering: .sequentiallyConsistent), 42)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }

  func test_Int16_compareExchange_relaxed() {
    let v = UnsafeAtomic<Int16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int16_compareExchange_acquiring() {
    let v = UnsafeAtomic<Int16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int16_compareExchange_releasing() {
    let v = UnsafeAtomic<Int16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int16_compareExchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<Int16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int16_compareExchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }

  func test_Int16_compareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<Int16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int16_compareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<Int16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int16_compareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int16_compareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<Int16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int16_compareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<Int16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int16_compareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int16_compareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<Int16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int16_compareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<Int16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int16_compareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int16_compareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<Int16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int16_compareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<Int16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int16_compareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int16_compareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<Int16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int16_compareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<Int16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int16_compareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int16_weakCompareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<Int16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int16_weakCompareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<Int16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int16_weakCompareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int16_weakCompareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<Int16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int16_weakCompareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<Int16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int16_weakCompareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int16_weakCompareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<Int16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int16_weakCompareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<Int16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int16_weakCompareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int16_weakCompareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<Int16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int16_weakCompareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<Int16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int16_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int16_weakCompareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<Int16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int16_weakCompareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<Int16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int16_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }

  func test_Int16_loadThenWrappingIncrement_relaxed() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a &+ b
    let result2: Int16 = result1 &+ c

    let v = UnsafeAtomic<Int16>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int16_loadThenWrappingIncrement_acquiring() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a &+ b
    let result2: Int16 = result1 &+ c

    let v = UnsafeAtomic<Int16>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int16_loadThenWrappingIncrement_releasing() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a &+ b
    let result2: Int16 = result1 &+ c

    let v = UnsafeAtomic<Int16>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int16_loadThenWrappingIncrement_acquiringAndReleasing() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a &+ b
    let result2: Int16 = result1 &+ c

    let v = UnsafeAtomic<Int16>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int16_loadThenWrappingIncrement_sequentiallyConsistent() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a &+ b
    let result2: Int16 = result1 &+ c

    let v = UnsafeAtomic<Int16>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int16_loadThenWrappingDecrement_relaxed() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a &- b
    let result2: Int16 = result1 &- c

    let v = UnsafeAtomic<Int16>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int16_loadThenWrappingDecrement_acquiring() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a &- b
    let result2: Int16 = result1 &- c

    let v = UnsafeAtomic<Int16>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int16_loadThenWrappingDecrement_releasing() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a &- b
    let result2: Int16 = result1 &- c

    let v = UnsafeAtomic<Int16>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int16_loadThenWrappingDecrement_acquiringAndReleasing() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a &- b
    let result2: Int16 = result1 &- c

    let v = UnsafeAtomic<Int16>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int16_loadThenWrappingDecrement_sequentiallyConsistent() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a &- b
    let result2: Int16 = result1 &- c

    let v = UnsafeAtomic<Int16>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int16_loadThenBitwiseAnd_relaxed() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a & b
    let result2: Int16 = result1 & c

    let v = UnsafeAtomic<Int16>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int16_loadThenBitwiseAnd_acquiring() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a & b
    let result2: Int16 = result1 & c

    let v = UnsafeAtomic<Int16>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int16_loadThenBitwiseAnd_releasing() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a & b
    let result2: Int16 = result1 & c

    let v = UnsafeAtomic<Int16>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int16_loadThenBitwiseAnd_acquiringAndReleasing() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a & b
    let result2: Int16 = result1 & c

    let v = UnsafeAtomic<Int16>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int16_loadThenBitwiseAnd_sequentiallyConsistent() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a & b
    let result2: Int16 = result1 & c

    let v = UnsafeAtomic<Int16>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int16_loadThenBitwiseOr_relaxed() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a | b
    let result2: Int16 = result1 | c

    let v = UnsafeAtomic<Int16>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int16_loadThenBitwiseOr_acquiring() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a | b
    let result2: Int16 = result1 | c

    let v = UnsafeAtomic<Int16>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int16_loadThenBitwiseOr_releasing() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a | b
    let result2: Int16 = result1 | c

    let v = UnsafeAtomic<Int16>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int16_loadThenBitwiseOr_acquiringAndReleasing() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a | b
    let result2: Int16 = result1 | c

    let v = UnsafeAtomic<Int16>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int16_loadThenBitwiseOr_sequentiallyConsistent() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a | b
    let result2: Int16 = result1 | c

    let v = UnsafeAtomic<Int16>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int16_loadThenBitwiseXor_relaxed() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a ^ b
    let result2: Int16 = result1 ^ c

    let v = UnsafeAtomic<Int16>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int16_loadThenBitwiseXor_acquiring() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a ^ b
    let result2: Int16 = result1 ^ c

    let v = UnsafeAtomic<Int16>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int16_loadThenBitwiseXor_releasing() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a ^ b
    let result2: Int16 = result1 ^ c

    let v = UnsafeAtomic<Int16>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int16_loadThenBitwiseXor_acquiringAndReleasing() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a ^ b
    let result2: Int16 = result1 ^ c

    let v = UnsafeAtomic<Int16>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int16_loadThenBitwiseXor_sequentiallyConsistent() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a ^ b
    let result2: Int16 = result1 ^ c

    let v = UnsafeAtomic<Int16>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }

  func test_Int16_wrappingIncrementThenLoad_relaxed() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a &+ b
    let result2: Int16 = result1 &+ c

    let v = UnsafeAtomic<Int16>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int16_wrappingIncrementThenLoad_acquiring() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a &+ b
    let result2: Int16 = result1 &+ c

    let v = UnsafeAtomic<Int16>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int16_wrappingIncrementThenLoad_releasing() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a &+ b
    let result2: Int16 = result1 &+ c

    let v = UnsafeAtomic<Int16>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int16_wrappingIncrementThenLoad_acquiringAndReleasing() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a &+ b
    let result2: Int16 = result1 &+ c

    let v = UnsafeAtomic<Int16>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int16_wrappingIncrementThenLoad_sequentiallyConsistent() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a &+ b
    let result2: Int16 = result1 &+ c

    let v = UnsafeAtomic<Int16>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int16_wrappingDecrementThenLoad_relaxed() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a &- b
    let result2: Int16 = result1 &- c

    let v = UnsafeAtomic<Int16>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int16_wrappingDecrementThenLoad_acquiring() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a &- b
    let result2: Int16 = result1 &- c

    let v = UnsafeAtomic<Int16>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int16_wrappingDecrementThenLoad_releasing() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a &- b
    let result2: Int16 = result1 &- c

    let v = UnsafeAtomic<Int16>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int16_wrappingDecrementThenLoad_acquiringAndReleasing() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a &- b
    let result2: Int16 = result1 &- c

    let v = UnsafeAtomic<Int16>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int16_wrappingDecrementThenLoad_sequentiallyConsistent() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a &- b
    let result2: Int16 = result1 &- c

    let v = UnsafeAtomic<Int16>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int16_bitwiseAndThenLoad_relaxed() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a & b
    let result2: Int16 = result1 & c

    let v = UnsafeAtomic<Int16>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int16_bitwiseAndThenLoad_acquiring() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a & b
    let result2: Int16 = result1 & c

    let v = UnsafeAtomic<Int16>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int16_bitwiseAndThenLoad_releasing() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a & b
    let result2: Int16 = result1 & c

    let v = UnsafeAtomic<Int16>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int16_bitwiseAndThenLoad_acquiringAndReleasing() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a & b
    let result2: Int16 = result1 & c

    let v = UnsafeAtomic<Int16>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int16_bitwiseAndThenLoad_sequentiallyConsistent() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a & b
    let result2: Int16 = result1 & c

    let v = UnsafeAtomic<Int16>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int16_bitwiseOrThenLoad_relaxed() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a | b
    let result2: Int16 = result1 | c

    let v = UnsafeAtomic<Int16>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int16_bitwiseOrThenLoad_acquiring() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a | b
    let result2: Int16 = result1 | c

    let v = UnsafeAtomic<Int16>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int16_bitwiseOrThenLoad_releasing() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a | b
    let result2: Int16 = result1 | c

    let v = UnsafeAtomic<Int16>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int16_bitwiseOrThenLoad_acquiringAndReleasing() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a | b
    let result2: Int16 = result1 | c

    let v = UnsafeAtomic<Int16>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int16_bitwiseOrThenLoad_sequentiallyConsistent() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a | b
    let result2: Int16 = result1 | c

    let v = UnsafeAtomic<Int16>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int16_bitwiseXorThenLoad_relaxed() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a ^ b
    let result2: Int16 = result1 ^ c

    let v = UnsafeAtomic<Int16>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int16_bitwiseXorThenLoad_acquiring() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a ^ b
    let result2: Int16 = result1 ^ c

    let v = UnsafeAtomic<Int16>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int16_bitwiseXorThenLoad_releasing() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a ^ b
    let result2: Int16 = result1 ^ c

    let v = UnsafeAtomic<Int16>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int16_bitwiseXorThenLoad_acquiringAndReleasing() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a ^ b
    let result2: Int16 = result1 ^ c

    let v = UnsafeAtomic<Int16>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int16_bitwiseXorThenLoad_sequentiallyConsistent() {
    let a: Int16 = 3
    let b: Int16 = 8
    let c: Int16 = 12
    let result1: Int16 = a ^ b
    let result2: Int16 = result1 ^ c

    let v = UnsafeAtomic<Int16>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }


  func test_UInt16_create_destroy() {
    let v = UnsafeAtomic<UInt16>.create(initialValue: 0)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), 0)

    let w = UnsafeAtomic<UInt16>.create(initialValue: 42)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), 42)
  }

  func test_UInt16_load_relaxed() {
    let v = UnsafeAtomic<UInt16>.create(initialValue: 0)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), 0)

    let w = UnsafeAtomic<UInt16>.create(initialValue: 23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), 23)
  }
  func test_UInt16_load_acquiring() {
    let v = UnsafeAtomic<UInt16>.create(initialValue: 0)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .acquiring), 0)

    let w = UnsafeAtomic<UInt16>.create(initialValue: 23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .acquiring), 23)
  }
  func test_UInt16_load_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt16>.create(initialValue: 0)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .sequentiallyConsistent), 0)

    let w = UnsafeAtomic<UInt16>.create(initialValue: 23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .sequentiallyConsistent), 23)
  }

  func test_UInt16_store_relaxed() {
    let v = UnsafeAtomic<UInt16>.create(initialValue: 0)
    defer { v.destroy() }

    v.store(23, ordering: .relaxed)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    v.store(42, ordering: .relaxed)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)
  }
  func test_UInt16_store_releasing() {
    let v = UnsafeAtomic<UInt16>.create(initialValue: 0)
    defer { v.destroy() }

    v.store(23, ordering: .releasing)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    v.store(42, ordering: .releasing)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)
  }
  func test_UInt16_store_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt16>.create(initialValue: 0)
    defer { v.destroy() }

    v.store(23, ordering: .sequentiallyConsistent)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    v.store(42, ordering: .sequentiallyConsistent)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)
  }

  func test_UInt16_exchange_relaxed() {
    let v = UnsafeAtomic<UInt16>.create(initialValue: 0)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(42, ordering: .relaxed), 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)

    XCTAssertEqual(v.exchange(23, ordering: .relaxed), 42)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_UInt16_exchange_acquiring() {
    let v = UnsafeAtomic<UInt16>.create(initialValue: 0)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(42, ordering: .acquiring), 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)

    XCTAssertEqual(v.exchange(23, ordering: .acquiring), 42)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_UInt16_exchange_releasing() {
    let v = UnsafeAtomic<UInt16>.create(initialValue: 0)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(42, ordering: .releasing), 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)

    XCTAssertEqual(v.exchange(23, ordering: .releasing), 42)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_UInt16_exchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<UInt16>.create(initialValue: 0)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(42, ordering: .acquiringAndReleasing), 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)

    XCTAssertEqual(v.exchange(23, ordering: .acquiringAndReleasing), 42)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_UInt16_exchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt16>.create(initialValue: 0)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(42, ordering: .sequentiallyConsistent), 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)

    XCTAssertEqual(v.exchange(23, ordering: .sequentiallyConsistent), 42)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }

  func test_UInt16_compareExchange_relaxed() {
    let v = UnsafeAtomic<UInt16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt16_compareExchange_acquiring() {
    let v = UnsafeAtomic<UInt16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt16_compareExchange_releasing() {
    let v = UnsafeAtomic<UInt16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt16_compareExchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<UInt16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt16_compareExchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }

  func test_UInt16_compareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<UInt16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt16_compareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<UInt16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt16_compareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt16_compareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<UInt16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt16_compareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<UInt16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt16_compareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt16_compareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<UInt16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt16_compareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<UInt16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt16_compareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt16_compareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<UInt16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt16_compareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<UInt16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt16_compareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt16_compareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<UInt16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt16_compareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<UInt16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt16_compareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt16_weakCompareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<UInt16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt16_weakCompareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<UInt16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt16_weakCompareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt16_weakCompareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<UInt16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt16_weakCompareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<UInt16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt16_weakCompareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt16_weakCompareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<UInt16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt16_weakCompareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<UInt16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt16_weakCompareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt16_weakCompareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<UInt16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt16_weakCompareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<UInt16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt16_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt16_weakCompareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<UInt16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt16_weakCompareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<UInt16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt16_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt16>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }

  func test_UInt16_loadThenWrappingIncrement_relaxed() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a &+ b
    let result2: UInt16 = result1 &+ c

    let v = UnsafeAtomic<UInt16>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt16_loadThenWrappingIncrement_acquiring() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a &+ b
    let result2: UInt16 = result1 &+ c

    let v = UnsafeAtomic<UInt16>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt16_loadThenWrappingIncrement_releasing() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a &+ b
    let result2: UInt16 = result1 &+ c

    let v = UnsafeAtomic<UInt16>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt16_loadThenWrappingIncrement_acquiringAndReleasing() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a &+ b
    let result2: UInt16 = result1 &+ c

    let v = UnsafeAtomic<UInt16>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt16_loadThenWrappingIncrement_sequentiallyConsistent() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a &+ b
    let result2: UInt16 = result1 &+ c

    let v = UnsafeAtomic<UInt16>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt16_loadThenWrappingDecrement_relaxed() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a &- b
    let result2: UInt16 = result1 &- c

    let v = UnsafeAtomic<UInt16>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt16_loadThenWrappingDecrement_acquiring() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a &- b
    let result2: UInt16 = result1 &- c

    let v = UnsafeAtomic<UInt16>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt16_loadThenWrappingDecrement_releasing() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a &- b
    let result2: UInt16 = result1 &- c

    let v = UnsafeAtomic<UInt16>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt16_loadThenWrappingDecrement_acquiringAndReleasing() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a &- b
    let result2: UInt16 = result1 &- c

    let v = UnsafeAtomic<UInt16>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt16_loadThenWrappingDecrement_sequentiallyConsistent() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a &- b
    let result2: UInt16 = result1 &- c

    let v = UnsafeAtomic<UInt16>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt16_loadThenBitwiseAnd_relaxed() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a & b
    let result2: UInt16 = result1 & c

    let v = UnsafeAtomic<UInt16>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt16_loadThenBitwiseAnd_acquiring() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a & b
    let result2: UInt16 = result1 & c

    let v = UnsafeAtomic<UInt16>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt16_loadThenBitwiseAnd_releasing() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a & b
    let result2: UInt16 = result1 & c

    let v = UnsafeAtomic<UInt16>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt16_loadThenBitwiseAnd_acquiringAndReleasing() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a & b
    let result2: UInt16 = result1 & c

    let v = UnsafeAtomic<UInt16>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt16_loadThenBitwiseAnd_sequentiallyConsistent() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a & b
    let result2: UInt16 = result1 & c

    let v = UnsafeAtomic<UInt16>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt16_loadThenBitwiseOr_relaxed() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a | b
    let result2: UInt16 = result1 | c

    let v = UnsafeAtomic<UInt16>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt16_loadThenBitwiseOr_acquiring() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a | b
    let result2: UInt16 = result1 | c

    let v = UnsafeAtomic<UInt16>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt16_loadThenBitwiseOr_releasing() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a | b
    let result2: UInt16 = result1 | c

    let v = UnsafeAtomic<UInt16>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt16_loadThenBitwiseOr_acquiringAndReleasing() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a | b
    let result2: UInt16 = result1 | c

    let v = UnsafeAtomic<UInt16>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt16_loadThenBitwiseOr_sequentiallyConsistent() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a | b
    let result2: UInt16 = result1 | c

    let v = UnsafeAtomic<UInt16>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt16_loadThenBitwiseXor_relaxed() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a ^ b
    let result2: UInt16 = result1 ^ c

    let v = UnsafeAtomic<UInt16>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt16_loadThenBitwiseXor_acquiring() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a ^ b
    let result2: UInt16 = result1 ^ c

    let v = UnsafeAtomic<UInt16>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt16_loadThenBitwiseXor_releasing() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a ^ b
    let result2: UInt16 = result1 ^ c

    let v = UnsafeAtomic<UInt16>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt16_loadThenBitwiseXor_acquiringAndReleasing() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a ^ b
    let result2: UInt16 = result1 ^ c

    let v = UnsafeAtomic<UInt16>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt16_loadThenBitwiseXor_sequentiallyConsistent() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a ^ b
    let result2: UInt16 = result1 ^ c

    let v = UnsafeAtomic<UInt16>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }

  func test_UInt16_wrappingIncrementThenLoad_relaxed() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a &+ b
    let result2: UInt16 = result1 &+ c

    let v = UnsafeAtomic<UInt16>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt16_wrappingIncrementThenLoad_acquiring() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a &+ b
    let result2: UInt16 = result1 &+ c

    let v = UnsafeAtomic<UInt16>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt16_wrappingIncrementThenLoad_releasing() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a &+ b
    let result2: UInt16 = result1 &+ c

    let v = UnsafeAtomic<UInt16>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt16_wrappingIncrementThenLoad_acquiringAndReleasing() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a &+ b
    let result2: UInt16 = result1 &+ c

    let v = UnsafeAtomic<UInt16>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt16_wrappingIncrementThenLoad_sequentiallyConsistent() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a &+ b
    let result2: UInt16 = result1 &+ c

    let v = UnsafeAtomic<UInt16>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt16_wrappingDecrementThenLoad_relaxed() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a &- b
    let result2: UInt16 = result1 &- c

    let v = UnsafeAtomic<UInt16>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt16_wrappingDecrementThenLoad_acquiring() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a &- b
    let result2: UInt16 = result1 &- c

    let v = UnsafeAtomic<UInt16>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt16_wrappingDecrementThenLoad_releasing() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a &- b
    let result2: UInt16 = result1 &- c

    let v = UnsafeAtomic<UInt16>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt16_wrappingDecrementThenLoad_acquiringAndReleasing() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a &- b
    let result2: UInt16 = result1 &- c

    let v = UnsafeAtomic<UInt16>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt16_wrappingDecrementThenLoad_sequentiallyConsistent() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a &- b
    let result2: UInt16 = result1 &- c

    let v = UnsafeAtomic<UInt16>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt16_bitwiseAndThenLoad_relaxed() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a & b
    let result2: UInt16 = result1 & c

    let v = UnsafeAtomic<UInt16>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt16_bitwiseAndThenLoad_acquiring() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a & b
    let result2: UInt16 = result1 & c

    let v = UnsafeAtomic<UInt16>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt16_bitwiseAndThenLoad_releasing() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a & b
    let result2: UInt16 = result1 & c

    let v = UnsafeAtomic<UInt16>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt16_bitwiseAndThenLoad_acquiringAndReleasing() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a & b
    let result2: UInt16 = result1 & c

    let v = UnsafeAtomic<UInt16>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt16_bitwiseAndThenLoad_sequentiallyConsistent() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a & b
    let result2: UInt16 = result1 & c

    let v = UnsafeAtomic<UInt16>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt16_bitwiseOrThenLoad_relaxed() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a | b
    let result2: UInt16 = result1 | c

    let v = UnsafeAtomic<UInt16>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt16_bitwiseOrThenLoad_acquiring() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a | b
    let result2: UInt16 = result1 | c

    let v = UnsafeAtomic<UInt16>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt16_bitwiseOrThenLoad_releasing() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a | b
    let result2: UInt16 = result1 | c

    let v = UnsafeAtomic<UInt16>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt16_bitwiseOrThenLoad_acquiringAndReleasing() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a | b
    let result2: UInt16 = result1 | c

    let v = UnsafeAtomic<UInt16>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt16_bitwiseOrThenLoad_sequentiallyConsistent() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a | b
    let result2: UInt16 = result1 | c

    let v = UnsafeAtomic<UInt16>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt16_bitwiseXorThenLoad_relaxed() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a ^ b
    let result2: UInt16 = result1 ^ c

    let v = UnsafeAtomic<UInt16>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt16_bitwiseXorThenLoad_acquiring() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a ^ b
    let result2: UInt16 = result1 ^ c

    let v = UnsafeAtomic<UInt16>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt16_bitwiseXorThenLoad_releasing() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a ^ b
    let result2: UInt16 = result1 ^ c

    let v = UnsafeAtomic<UInt16>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt16_bitwiseXorThenLoad_acquiringAndReleasing() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a ^ b
    let result2: UInt16 = result1 ^ c

    let v = UnsafeAtomic<UInt16>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt16_bitwiseXorThenLoad_sequentiallyConsistent() {
    let a: UInt16 = 3
    let b: UInt16 = 8
    let c: UInt16 = 12
    let result1: UInt16 = a ^ b
    let result2: UInt16 = result1 ^ c

    let v = UnsafeAtomic<UInt16>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }


  func test_Int8_create_destroy() {
    let v = UnsafeAtomic<Int8>.create(initialValue: 0)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), 0)

    let w = UnsafeAtomic<Int8>.create(initialValue: 42)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), 42)
  }

  func test_Int8_load_relaxed() {
    let v = UnsafeAtomic<Int8>.create(initialValue: 0)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), 0)

    let w = UnsafeAtomic<Int8>.create(initialValue: 23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), 23)
  }
  func test_Int8_load_acquiring() {
    let v = UnsafeAtomic<Int8>.create(initialValue: 0)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .acquiring), 0)

    let w = UnsafeAtomic<Int8>.create(initialValue: 23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .acquiring), 23)
  }
  func test_Int8_load_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int8>.create(initialValue: 0)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .sequentiallyConsistent), 0)

    let w = UnsafeAtomic<Int8>.create(initialValue: 23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .sequentiallyConsistent), 23)
  }

  func test_Int8_store_relaxed() {
    let v = UnsafeAtomic<Int8>.create(initialValue: 0)
    defer { v.destroy() }

    v.store(23, ordering: .relaxed)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    v.store(42, ordering: .relaxed)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)
  }
  func test_Int8_store_releasing() {
    let v = UnsafeAtomic<Int8>.create(initialValue: 0)
    defer { v.destroy() }

    v.store(23, ordering: .releasing)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    v.store(42, ordering: .releasing)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)
  }
  func test_Int8_store_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int8>.create(initialValue: 0)
    defer { v.destroy() }

    v.store(23, ordering: .sequentiallyConsistent)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    v.store(42, ordering: .sequentiallyConsistent)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)
  }

  func test_Int8_exchange_relaxed() {
    let v = UnsafeAtomic<Int8>.create(initialValue: 0)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(42, ordering: .relaxed), 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)

    XCTAssertEqual(v.exchange(23, ordering: .relaxed), 42)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_Int8_exchange_acquiring() {
    let v = UnsafeAtomic<Int8>.create(initialValue: 0)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(42, ordering: .acquiring), 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)

    XCTAssertEqual(v.exchange(23, ordering: .acquiring), 42)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_Int8_exchange_releasing() {
    let v = UnsafeAtomic<Int8>.create(initialValue: 0)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(42, ordering: .releasing), 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)

    XCTAssertEqual(v.exchange(23, ordering: .releasing), 42)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_Int8_exchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<Int8>.create(initialValue: 0)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(42, ordering: .acquiringAndReleasing), 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)

    XCTAssertEqual(v.exchange(23, ordering: .acquiringAndReleasing), 42)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_Int8_exchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int8>.create(initialValue: 0)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(42, ordering: .sequentiallyConsistent), 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)

    XCTAssertEqual(v.exchange(23, ordering: .sequentiallyConsistent), 42)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }

  func test_Int8_compareExchange_relaxed() {
    let v = UnsafeAtomic<Int8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int8_compareExchange_acquiring() {
    let v = UnsafeAtomic<Int8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int8_compareExchange_releasing() {
    let v = UnsafeAtomic<Int8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int8_compareExchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<Int8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int8_compareExchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }

  func test_Int8_compareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<Int8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int8_compareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<Int8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int8_compareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int8_compareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<Int8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int8_compareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<Int8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int8_compareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int8_compareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<Int8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int8_compareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<Int8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int8_compareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int8_compareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<Int8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int8_compareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<Int8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int8_compareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int8_compareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<Int8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int8_compareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<Int8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int8_compareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int8_weakCompareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<Int8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int8_weakCompareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<Int8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int8_weakCompareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int8_weakCompareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<Int8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int8_weakCompareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<Int8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int8_weakCompareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int8_weakCompareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<Int8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int8_weakCompareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<Int8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int8_weakCompareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int8_weakCompareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<Int8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int8_weakCompareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<Int8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int8_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int8_weakCompareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<Int8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int8_weakCompareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<Int8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_Int8_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<Int8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }

  func test_Int8_loadThenWrappingIncrement_relaxed() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a &+ b
    let result2: Int8 = result1 &+ c

    let v = UnsafeAtomic<Int8>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int8_loadThenWrappingIncrement_acquiring() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a &+ b
    let result2: Int8 = result1 &+ c

    let v = UnsafeAtomic<Int8>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int8_loadThenWrappingIncrement_releasing() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a &+ b
    let result2: Int8 = result1 &+ c

    let v = UnsafeAtomic<Int8>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int8_loadThenWrappingIncrement_acquiringAndReleasing() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a &+ b
    let result2: Int8 = result1 &+ c

    let v = UnsafeAtomic<Int8>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int8_loadThenWrappingIncrement_sequentiallyConsistent() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a &+ b
    let result2: Int8 = result1 &+ c

    let v = UnsafeAtomic<Int8>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int8_loadThenWrappingDecrement_relaxed() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a &- b
    let result2: Int8 = result1 &- c

    let v = UnsafeAtomic<Int8>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int8_loadThenWrappingDecrement_acquiring() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a &- b
    let result2: Int8 = result1 &- c

    let v = UnsafeAtomic<Int8>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int8_loadThenWrappingDecrement_releasing() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a &- b
    let result2: Int8 = result1 &- c

    let v = UnsafeAtomic<Int8>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int8_loadThenWrappingDecrement_acquiringAndReleasing() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a &- b
    let result2: Int8 = result1 &- c

    let v = UnsafeAtomic<Int8>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int8_loadThenWrappingDecrement_sequentiallyConsistent() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a &- b
    let result2: Int8 = result1 &- c

    let v = UnsafeAtomic<Int8>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int8_loadThenBitwiseAnd_relaxed() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a & b
    let result2: Int8 = result1 & c

    let v = UnsafeAtomic<Int8>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int8_loadThenBitwiseAnd_acquiring() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a & b
    let result2: Int8 = result1 & c

    let v = UnsafeAtomic<Int8>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int8_loadThenBitwiseAnd_releasing() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a & b
    let result2: Int8 = result1 & c

    let v = UnsafeAtomic<Int8>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int8_loadThenBitwiseAnd_acquiringAndReleasing() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a & b
    let result2: Int8 = result1 & c

    let v = UnsafeAtomic<Int8>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int8_loadThenBitwiseAnd_sequentiallyConsistent() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a & b
    let result2: Int8 = result1 & c

    let v = UnsafeAtomic<Int8>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int8_loadThenBitwiseOr_relaxed() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a | b
    let result2: Int8 = result1 | c

    let v = UnsafeAtomic<Int8>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int8_loadThenBitwiseOr_acquiring() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a | b
    let result2: Int8 = result1 | c

    let v = UnsafeAtomic<Int8>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int8_loadThenBitwiseOr_releasing() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a | b
    let result2: Int8 = result1 | c

    let v = UnsafeAtomic<Int8>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int8_loadThenBitwiseOr_acquiringAndReleasing() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a | b
    let result2: Int8 = result1 | c

    let v = UnsafeAtomic<Int8>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int8_loadThenBitwiseOr_sequentiallyConsistent() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a | b
    let result2: Int8 = result1 | c

    let v = UnsafeAtomic<Int8>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int8_loadThenBitwiseXor_relaxed() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a ^ b
    let result2: Int8 = result1 ^ c

    let v = UnsafeAtomic<Int8>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int8_loadThenBitwiseXor_acquiring() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a ^ b
    let result2: Int8 = result1 ^ c

    let v = UnsafeAtomic<Int8>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int8_loadThenBitwiseXor_releasing() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a ^ b
    let result2: Int8 = result1 ^ c

    let v = UnsafeAtomic<Int8>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int8_loadThenBitwiseXor_acquiringAndReleasing() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a ^ b
    let result2: Int8 = result1 ^ c

    let v = UnsafeAtomic<Int8>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int8_loadThenBitwiseXor_sequentiallyConsistent() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a ^ b
    let result2: Int8 = result1 ^ c

    let v = UnsafeAtomic<Int8>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }

  func test_Int8_wrappingIncrementThenLoad_relaxed() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a &+ b
    let result2: Int8 = result1 &+ c

    let v = UnsafeAtomic<Int8>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int8_wrappingIncrementThenLoad_acquiring() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a &+ b
    let result2: Int8 = result1 &+ c

    let v = UnsafeAtomic<Int8>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int8_wrappingIncrementThenLoad_releasing() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a &+ b
    let result2: Int8 = result1 &+ c

    let v = UnsafeAtomic<Int8>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int8_wrappingIncrementThenLoad_acquiringAndReleasing() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a &+ b
    let result2: Int8 = result1 &+ c

    let v = UnsafeAtomic<Int8>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int8_wrappingIncrementThenLoad_sequentiallyConsistent() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a &+ b
    let result2: Int8 = result1 &+ c

    let v = UnsafeAtomic<Int8>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int8_wrappingDecrementThenLoad_relaxed() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a &- b
    let result2: Int8 = result1 &- c

    let v = UnsafeAtomic<Int8>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int8_wrappingDecrementThenLoad_acquiring() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a &- b
    let result2: Int8 = result1 &- c

    let v = UnsafeAtomic<Int8>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int8_wrappingDecrementThenLoad_releasing() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a &- b
    let result2: Int8 = result1 &- c

    let v = UnsafeAtomic<Int8>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int8_wrappingDecrementThenLoad_acquiringAndReleasing() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a &- b
    let result2: Int8 = result1 &- c

    let v = UnsafeAtomic<Int8>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int8_wrappingDecrementThenLoad_sequentiallyConsistent() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a &- b
    let result2: Int8 = result1 &- c

    let v = UnsafeAtomic<Int8>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int8_bitwiseAndThenLoad_relaxed() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a & b
    let result2: Int8 = result1 & c

    let v = UnsafeAtomic<Int8>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int8_bitwiseAndThenLoad_acquiring() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a & b
    let result2: Int8 = result1 & c

    let v = UnsafeAtomic<Int8>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int8_bitwiseAndThenLoad_releasing() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a & b
    let result2: Int8 = result1 & c

    let v = UnsafeAtomic<Int8>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int8_bitwiseAndThenLoad_acquiringAndReleasing() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a & b
    let result2: Int8 = result1 & c

    let v = UnsafeAtomic<Int8>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int8_bitwiseAndThenLoad_sequentiallyConsistent() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a & b
    let result2: Int8 = result1 & c

    let v = UnsafeAtomic<Int8>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int8_bitwiseOrThenLoad_relaxed() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a | b
    let result2: Int8 = result1 | c

    let v = UnsafeAtomic<Int8>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int8_bitwiseOrThenLoad_acquiring() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a | b
    let result2: Int8 = result1 | c

    let v = UnsafeAtomic<Int8>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int8_bitwiseOrThenLoad_releasing() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a | b
    let result2: Int8 = result1 | c

    let v = UnsafeAtomic<Int8>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int8_bitwiseOrThenLoad_acquiringAndReleasing() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a | b
    let result2: Int8 = result1 | c

    let v = UnsafeAtomic<Int8>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int8_bitwiseOrThenLoad_sequentiallyConsistent() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a | b
    let result2: Int8 = result1 | c

    let v = UnsafeAtomic<Int8>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int8_bitwiseXorThenLoad_relaxed() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a ^ b
    let result2: Int8 = result1 ^ c

    let v = UnsafeAtomic<Int8>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int8_bitwiseXorThenLoad_acquiring() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a ^ b
    let result2: Int8 = result1 ^ c

    let v = UnsafeAtomic<Int8>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int8_bitwiseXorThenLoad_releasing() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a ^ b
    let result2: Int8 = result1 ^ c

    let v = UnsafeAtomic<Int8>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int8_bitwiseXorThenLoad_acquiringAndReleasing() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a ^ b
    let result2: Int8 = result1 ^ c

    let v = UnsafeAtomic<Int8>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_Int8_bitwiseXorThenLoad_sequentiallyConsistent() {
    let a: Int8 = 3
    let b: Int8 = 8
    let c: Int8 = 12
    let result1: Int8 = a ^ b
    let result2: Int8 = result1 ^ c

    let v = UnsafeAtomic<Int8>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }


  func test_UInt8_create_destroy() {
    let v = UnsafeAtomic<UInt8>.create(initialValue: 0)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), 0)

    let w = UnsafeAtomic<UInt8>.create(initialValue: 42)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), 42)
  }

  func test_UInt8_load_relaxed() {
    let v = UnsafeAtomic<UInt8>.create(initialValue: 0)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .relaxed), 0)

    let w = UnsafeAtomic<UInt8>.create(initialValue: 23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .relaxed), 23)
  }
  func test_UInt8_load_acquiring() {
    let v = UnsafeAtomic<UInt8>.create(initialValue: 0)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .acquiring), 0)

    let w = UnsafeAtomic<UInt8>.create(initialValue: 23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .acquiring), 23)
  }
  func test_UInt8_load_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt8>.create(initialValue: 0)
    defer { v.destroy() }
    XCTAssertEqual(v.load(ordering: .sequentiallyConsistent), 0)

    let w = UnsafeAtomic<UInt8>.create(initialValue: 23)
    defer { w.destroy() }
    XCTAssertEqual(w.load(ordering: .sequentiallyConsistent), 23)
  }

  func test_UInt8_store_relaxed() {
    let v = UnsafeAtomic<UInt8>.create(initialValue: 0)
    defer { v.destroy() }

    v.store(23, ordering: .relaxed)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    v.store(42, ordering: .relaxed)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)
  }
  func test_UInt8_store_releasing() {
    let v = UnsafeAtomic<UInt8>.create(initialValue: 0)
    defer { v.destroy() }

    v.store(23, ordering: .releasing)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    v.store(42, ordering: .releasing)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)
  }
  func test_UInt8_store_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt8>.create(initialValue: 0)
    defer { v.destroy() }

    v.store(23, ordering: .sequentiallyConsistent)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)

    v.store(42, ordering: .sequentiallyConsistent)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)
  }

  func test_UInt8_exchange_relaxed() {
    let v = UnsafeAtomic<UInt8>.create(initialValue: 0)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(42, ordering: .relaxed), 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)

    XCTAssertEqual(v.exchange(23, ordering: .relaxed), 42)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_UInt8_exchange_acquiring() {
    let v = UnsafeAtomic<UInt8>.create(initialValue: 0)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(42, ordering: .acquiring), 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)

    XCTAssertEqual(v.exchange(23, ordering: .acquiring), 42)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_UInt8_exchange_releasing() {
    let v = UnsafeAtomic<UInt8>.create(initialValue: 0)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(42, ordering: .releasing), 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)

    XCTAssertEqual(v.exchange(23, ordering: .releasing), 42)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_UInt8_exchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<UInt8>.create(initialValue: 0)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(42, ordering: .acquiringAndReleasing), 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)

    XCTAssertEqual(v.exchange(23, ordering: .acquiringAndReleasing), 42)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }
  func test_UInt8_exchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt8>.create(initialValue: 0)
    defer { v.destroy() }

    XCTAssertEqual(v.exchange(42, ordering: .sequentiallyConsistent), 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 42)

    XCTAssertEqual(v.exchange(23, ordering: .sequentiallyConsistent), 42)
    XCTAssertEqual(v.load(ordering: .relaxed), 23)
  }

  func test_UInt8_compareExchange_relaxed() {
    let v = UnsafeAtomic<UInt8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      ordering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      ordering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt8_compareExchange_acquiring() {
    let v = UnsafeAtomic<UInt8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      ordering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      ordering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt8_compareExchange_releasing() {
    let v = UnsafeAtomic<UInt8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      ordering: .releasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      ordering: .releasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt8_compareExchange_acquiringAndReleasing() {
    let v = UnsafeAtomic<UInt8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      ordering: .acquiringAndReleasing)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      ordering: .acquiringAndReleasing)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt8_compareExchange_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      ordering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      ordering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }

  func test_UInt8_compareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<UInt8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt8_compareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<UInt8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt8_compareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt8_compareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<UInt8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt8_compareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<UInt8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt8_compareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt8_compareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<UInt8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt8_compareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<UInt8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt8_compareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt8_compareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<UInt8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt8_compareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<UInt8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt8_compareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt8_compareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<UInt8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt8_compareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<UInt8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt8_compareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.compareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt8_weakCompareExchange_relaxed_relaxed() {
    let v = UnsafeAtomic<UInt8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt8_weakCompareExchange_relaxed_acquiring() {
    let v = UnsafeAtomic<UInt8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt8_weakCompareExchange_relaxed_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .relaxed,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt8_weakCompareExchange_acquiring_relaxed() {
    let v = UnsafeAtomic<UInt8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt8_weakCompareExchange_acquiring_acquiring() {
    let v = UnsafeAtomic<UInt8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt8_weakCompareExchange_acquiring_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiring,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt8_weakCompareExchange_releasing_relaxed() {
    let v = UnsafeAtomic<UInt8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt8_weakCompareExchange_releasing_acquiring() {
    let v = UnsafeAtomic<UInt8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt8_weakCompareExchange_releasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .releasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt8_weakCompareExchange_acquiringAndReleasing_relaxed() {
    let v = UnsafeAtomic<UInt8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt8_weakCompareExchange_acquiringAndReleasing_acquiring() {
    let v = UnsafeAtomic<UInt8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt8_weakCompareExchange_acquiringAndReleasing_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .acquiringAndReleasing,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt8_weakCompareExchange_sequentiallyConsistent_relaxed() {
    let v = UnsafeAtomic<UInt8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .relaxed)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt8_weakCompareExchange_sequentiallyConsistent_acquiring() {
    let v = UnsafeAtomic<UInt8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .acquiring)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }
  func test_UInt8_weakCompareExchange_sequentiallyConsistent_sequentiallyConsistent() {
    let v = UnsafeAtomic<UInt8>.create(initialValue: 0)
    defer { v.destroy() }

    var (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 1,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 0)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 0,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertFalse(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 1)

    (exchanged, original) = v.weakCompareExchange(
      expected: 1,
      desired: 2,
      successOrdering: .sequentiallyConsistent,
      failureOrdering: .sequentiallyConsistent)
    XCTAssertTrue(exchanged)
    XCTAssertEqual(original, 1)
    XCTAssertEqual(v.load(ordering: .relaxed), 2)
  }

  func test_UInt8_loadThenWrappingIncrement_relaxed() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a &+ b
    let result2: UInt8 = result1 &+ c

    let v = UnsafeAtomic<UInt8>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt8_loadThenWrappingIncrement_acquiring() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a &+ b
    let result2: UInt8 = result1 &+ c

    let v = UnsafeAtomic<UInt8>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt8_loadThenWrappingIncrement_releasing() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a &+ b
    let result2: UInt8 = result1 &+ c

    let v = UnsafeAtomic<UInt8>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt8_loadThenWrappingIncrement_acquiringAndReleasing() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a &+ b
    let result2: UInt8 = result1 &+ c

    let v = UnsafeAtomic<UInt8>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt8_loadThenWrappingIncrement_sequentiallyConsistent() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a &+ b
    let result2: UInt8 = result1 &+ c

    let v = UnsafeAtomic<UInt8>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingIncrement(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingIncrement(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt8_loadThenWrappingDecrement_relaxed() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a &- b
    let result2: UInt8 = result1 &- c

    let v = UnsafeAtomic<UInt8>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt8_loadThenWrappingDecrement_acquiring() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a &- b
    let result2: UInt8 = result1 &- c

    let v = UnsafeAtomic<UInt8>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt8_loadThenWrappingDecrement_releasing() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a &- b
    let result2: UInt8 = result1 &- c

    let v = UnsafeAtomic<UInt8>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt8_loadThenWrappingDecrement_acquiringAndReleasing() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a &- b
    let result2: UInt8 = result1 &- c

    let v = UnsafeAtomic<UInt8>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt8_loadThenWrappingDecrement_sequentiallyConsistent() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a &- b
    let result2: UInt8 = result1 &- c

    let v = UnsafeAtomic<UInt8>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenWrappingDecrement(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenWrappingDecrement(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt8_loadThenBitwiseAnd_relaxed() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a & b
    let result2: UInt8 = result1 & c

    let v = UnsafeAtomic<UInt8>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt8_loadThenBitwiseAnd_acquiring() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a & b
    let result2: UInt8 = result1 & c

    let v = UnsafeAtomic<UInt8>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt8_loadThenBitwiseAnd_releasing() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a & b
    let result2: UInt8 = result1 & c

    let v = UnsafeAtomic<UInt8>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt8_loadThenBitwiseAnd_acquiringAndReleasing() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a & b
    let result2: UInt8 = result1 & c

    let v = UnsafeAtomic<UInt8>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt8_loadThenBitwiseAnd_sequentiallyConsistent() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a & b
    let result2: UInt8 = result1 & c

    let v = UnsafeAtomic<UInt8>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseAnd(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseAnd(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt8_loadThenBitwiseOr_relaxed() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a | b
    let result2: UInt8 = result1 | c

    let v = UnsafeAtomic<UInt8>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt8_loadThenBitwiseOr_acquiring() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a | b
    let result2: UInt8 = result1 | c

    let v = UnsafeAtomic<UInt8>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt8_loadThenBitwiseOr_releasing() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a | b
    let result2: UInt8 = result1 | c

    let v = UnsafeAtomic<UInt8>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt8_loadThenBitwiseOr_acquiringAndReleasing() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a | b
    let result2: UInt8 = result1 | c

    let v = UnsafeAtomic<UInt8>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt8_loadThenBitwiseOr_sequentiallyConsistent() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a | b
    let result2: UInt8 = result1 | c

    let v = UnsafeAtomic<UInt8>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseOr(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseOr(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt8_loadThenBitwiseXor_relaxed() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a ^ b
    let result2: UInt8 = result1 ^ c

    let v = UnsafeAtomic<UInt8>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .relaxed)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .relaxed)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt8_loadThenBitwiseXor_acquiring() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a ^ b
    let result2: UInt8 = result1 ^ c

    let v = UnsafeAtomic<UInt8>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .acquiring)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .acquiring)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt8_loadThenBitwiseXor_releasing() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a ^ b
    let result2: UInt8 = result1 ^ c

    let v = UnsafeAtomic<UInt8>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .releasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .releasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt8_loadThenBitwiseXor_acquiringAndReleasing() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a ^ b
    let result2: UInt8 = result1 ^ c

    let v = UnsafeAtomic<UInt8>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt8_loadThenBitwiseXor_sequentiallyConsistent() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a ^ b
    let result2: UInt8 = result1 ^ c

    let v = UnsafeAtomic<UInt8>.create(initialValue: a)
    defer { v.destroy() }

    let old1 = v.loadThenBitwiseXor(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old1, a)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let old2 = v.loadThenBitwiseXor(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(old2, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }

  func test_UInt8_wrappingIncrementThenLoad_relaxed() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a &+ b
    let result2: UInt8 = result1 &+ c

    let v = UnsafeAtomic<UInt8>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt8_wrappingIncrementThenLoad_acquiring() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a &+ b
    let result2: UInt8 = result1 &+ c

    let v = UnsafeAtomic<UInt8>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt8_wrappingIncrementThenLoad_releasing() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a &+ b
    let result2: UInt8 = result1 &+ c

    let v = UnsafeAtomic<UInt8>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt8_wrappingIncrementThenLoad_acquiringAndReleasing() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a &+ b
    let result2: UInt8 = result1 &+ c

    let v = UnsafeAtomic<UInt8>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt8_wrappingIncrementThenLoad_sequentiallyConsistent() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a &+ b
    let result2: UInt8 = result1 &+ c

    let v = UnsafeAtomic<UInt8>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingIncrementThenLoad(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingIncrementThenLoad(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt8_wrappingDecrementThenLoad_relaxed() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a &- b
    let result2: UInt8 = result1 &- c

    let v = UnsafeAtomic<UInt8>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt8_wrappingDecrementThenLoad_acquiring() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a &- b
    let result2: UInt8 = result1 &- c

    let v = UnsafeAtomic<UInt8>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt8_wrappingDecrementThenLoad_releasing() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a &- b
    let result2: UInt8 = result1 &- c

    let v = UnsafeAtomic<UInt8>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt8_wrappingDecrementThenLoad_acquiringAndReleasing() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a &- b
    let result2: UInt8 = result1 &- c

    let v = UnsafeAtomic<UInt8>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt8_wrappingDecrementThenLoad_sequentiallyConsistent() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a &- b
    let result2: UInt8 = result1 &- c

    let v = UnsafeAtomic<UInt8>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.wrappingDecrementThenLoad(by: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.wrappingDecrementThenLoad(by: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt8_bitwiseAndThenLoad_relaxed() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a & b
    let result2: UInt8 = result1 & c

    let v = UnsafeAtomic<UInt8>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt8_bitwiseAndThenLoad_acquiring() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a & b
    let result2: UInt8 = result1 & c

    let v = UnsafeAtomic<UInt8>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt8_bitwiseAndThenLoad_releasing() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a & b
    let result2: UInt8 = result1 & c

    let v = UnsafeAtomic<UInt8>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt8_bitwiseAndThenLoad_acquiringAndReleasing() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a & b
    let result2: UInt8 = result1 & c

    let v = UnsafeAtomic<UInt8>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt8_bitwiseAndThenLoad_sequentiallyConsistent() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a & b
    let result2: UInt8 = result1 & c

    let v = UnsafeAtomic<UInt8>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseAndThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseAndThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt8_bitwiseOrThenLoad_relaxed() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a | b
    let result2: UInt8 = result1 | c

    let v = UnsafeAtomic<UInt8>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt8_bitwiseOrThenLoad_acquiring() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a | b
    let result2: UInt8 = result1 | c

    let v = UnsafeAtomic<UInt8>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt8_bitwiseOrThenLoad_releasing() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a | b
    let result2: UInt8 = result1 | c

    let v = UnsafeAtomic<UInt8>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt8_bitwiseOrThenLoad_acquiringAndReleasing() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a | b
    let result2: UInt8 = result1 | c

    let v = UnsafeAtomic<UInt8>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt8_bitwiseOrThenLoad_sequentiallyConsistent() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a | b
    let result2: UInt8 = result1 | c

    let v = UnsafeAtomic<UInt8>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseOrThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseOrThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt8_bitwiseXorThenLoad_relaxed() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a ^ b
    let result2: UInt8 = result1 ^ c

    let v = UnsafeAtomic<UInt8>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .relaxed)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .relaxed)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt8_bitwiseXorThenLoad_acquiring() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a ^ b
    let result2: UInt8 = result1 ^ c

    let v = UnsafeAtomic<UInt8>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .acquiring)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .acquiring)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt8_bitwiseXorThenLoad_releasing() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a ^ b
    let result2: UInt8 = result1 ^ c

    let v = UnsafeAtomic<UInt8>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .releasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .releasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt8_bitwiseXorThenLoad_acquiringAndReleasing() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a ^ b
    let result2: UInt8 = result1 ^ c

    let v = UnsafeAtomic<UInt8>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .acquiringAndReleasing)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }
  func test_UInt8_bitwiseXorThenLoad_sequentiallyConsistent() {
    let a: UInt8 = 3
    let b: UInt8 = 8
    let c: UInt8 = 12
    let result1: UInt8 = a ^ b
    let result2: UInt8 = result1 ^ c

    let v = UnsafeAtomic<UInt8>.create(initialValue: a)
    defer { v.destroy() }

    let new1 = v.bitwiseXorThenLoad(with: b, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new1, result1)
    XCTAssertEqual(v.load(ordering: .relaxed), result1)

    let new2 = v.bitwiseXorThenLoad(with: c, ordering: .sequentiallyConsistent)
    XCTAssertEqual(new2, result2)
    XCTAssertEqual(v.load(ordering: .relaxed), result2)
  }

}
